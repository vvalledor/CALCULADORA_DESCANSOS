<!DOCTYPE html>
<!--
================================================================================
CALCULADORA DE DESCANSOS ENTRE JORNADES
================================================================================

Copyright (c) 2025 Adrian Valledor Lopez. Todos los derechos reservados.

AVISO LEGAL DE PROPIEDAD INTELECTUAL

TITULAR DE LOS DERECHOS:
Adrian Valledor Lopez es el √∫nico autor, creador y titular exclusivo de todos
los derechos de propiedad intelectual sobre este software y su c√≥digo fuente.

DERECHOS RESERVADOS:
Este software est√° protegido por las leyes de propiedad intelectual y derechos
de autor vigentes en Espa√±a y por los tratados internacionales aplicables.
El autor se reserva expresamente todos los derechos sobre este c√≥digo, incluyendo
de forma no limitativa: derechos de modificaci√≥n, edici√≥n, distribuci√≥n,
reproducci√≥n, explotaci√≥n comercial y control absoluto del c√≥digo fuente.

CESI√ìN LIMITADA DE DERECHOS DE USO:
Los derechos de uso operativo de este software se ceden exclusivamente al
HOSPITAL DEL MAR DE BARCELONA. Esta cesi√≥n autoriza √∫nicamente el uso interno
del software para los fines previstos, sin que implique transferencia alguna
de derechos de propiedad intelectual, modificaci√≥n, distribuci√≥n o explotaci√≥n.

PROHIBICIONES:
Queda terminantemente prohibido sin autorizaci√≥n expresa y por escrito del autor:
- Copiar, reproducir o duplicar total o parcialmente este c√≥digo fuente
- Distribuir, publicar, compartir o poner a disposici√≥n de terceros
- Modificar, editar, alterar o adaptar el c√≥digo fuente
- Realizar ingenier√≠a inversa, descompilar o desensamblar
- Crear obras derivadas basadas en este software
- Comercializar, vender, licenciar o sublicenciar
- Transferir o ceder a terceros cualquier derecho sobre el software

LIMITACI√ìN DE RESPONSABILIDAD:
Este software se proporciona "tal cual" sin garant√≠as de ning√∫n tipo, ya sean
expresas o impl√≠citas. El autor no asume responsabilidad alguna por da√±os
directos, indirectos, incidentales, especiales o consecuentes que pudieran
derivarse del uso o imposibilidad de uso de este software.

La violaci√≥n de cualquiera de las condiciones establecidas en este aviso legal
dar√° lugar a las acciones legales que correspondan conforme a la legislaci√≥n
aplicable en materia de propiedad intelectual.

Autor: Adrian Valledor Lopez
Fecha de creaci√≥n: Noviembre 2025
Versi√≥n: 2.0

ESTE AVISO DE COPYRIGHT Y PROPIEDAD INTELECTUAL NO PUEDE SER ELIMINADO,
MODIFICADO NI OCULTADO BAJO NINGUNA CIRCUNSTANCIA.

================================================================================
-->
<html lang="ca">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Calculadora de Descansos entre Jornades</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"/>
  <style>
    :root {
      /* Variables CSS centralizadas para mayor coherencia */
      --color-primary: #0078d4;
      --color-primary-dark: #005a9e;
      --color-primary-light: #e8f4fd;
      --color-morning: #3498db;
      --color-afternoon: #e74c3c;
      --color-double: #9b59b6;
      --color-success: #27ae60;
      --color-warning: #e74c3c;
      --color-text: #333;
      --color-text-light: #666;
      --color-background: #fff;
      --color-background-alt: #f8f9fa;
      --color-border: #dee2e6;
      --shadow: 0 2px 10px rgba(0,0,0,0.1);
      --shadow-hover: 0 4px 20px rgba(0,0,0,0.15);
      --shadow-active: 0 1px 5px rgba(0,0,0,0.1);
      --radius: 8px;
      --radius-small: 6px;
      --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      --transition-fast: all 0.15s ease;
      /* Estilos para turnos sugeridos */
      --bg-sugerido: #fffbea;
      --border-sugerido: #f0c674;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Roboto', sans-serif;
    }
    
    body {
      background: linear-gradient(135deg, #f0f4f8 0%, #d9e2ec 50%, #e8eff5 100%);
      background-attachment: fixed;
      color: var(--color-text);
      line-height: 1.6;
      padding: 20px;
      min-height: 100vh;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: var(--color-background);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    
    header {
      background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
      color: white;
      padding: 30px 25px;
      text-align: center;
      position: relative;
      overflow: hidden;
    }
    
    header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, transparent 100%);
      pointer-events: none;
    }
    
    h1 {
      font-size: 26px;
      margin-bottom: 8px;
      font-weight: 600;
      letter-spacing: -0.5px;
      position: relative;
    }
    
    .subheader {
      font-size: 14px;
      opacity: 0.95;
      font-weight: 400;
      letter-spacing: 0.2px;
      position: relative;
    }
    
    /* Pesta√±as */
    .tabs {
      display: flex;
      background-color: var(--color-background-alt);
      border-bottom: 1px solid var(--color-border);
    }
    
    .tab {
      padding: 15px 25px;
      cursor: pointer;
      font-weight: 500;
      transition: var(--transition);
      border-bottom: 3px solid transparent;
      position: relative;
    }
    
    .tab::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 50%;
      width: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--color-primary), var(--color-primary-dark));
      transform: translateX(-50%);
      transition: width 0.3s ease;
    }
    
    .tab.active {
      color: var(--color-primary);
      font-weight: 600;
    }
    
    .tab.active::after {
      width: 100%;
    }
    
    .tab:hover { 
      background-color: #e9ecef; 
    }
    
    .tab-content {
      display: none;
      padding: 25px;
    }
    
    .tab-content.active {
      display: block;
    }
    
    /* Secuencia de turnos */
    .turnos-container {
      margin-bottom: 30px;
    }
    
    .turnos-titulo {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    
    .turnos-titulo h2 {
      font-size: 18px;
      color: var(--color-primary);
    }
    
    .turnos-control {
      display: flex;
      gap: 10px;
    }
    
    .btn {
      padding: 10px 18px;
      border: none;
      border-radius: var(--radius-small);
      cursor: pointer;
      font-weight: 500;
      font-size: 14px;
      transition: var(--transition);
      display: flex;
      align-items: center;
      gap: 6px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.08);
      position: relative;
      overflow: hidden;
    }
    
    .btn::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255,255,255,0.2);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }
    
    .btn:hover::before {
      width: 300px;
      height: 300px;
    }
    
    .btn-primary {
      background-color: var(--color-primary);
      color: white;
    }
    
    .btn-secondary {
      background-color: #6c757d;
      color: white;
    }
    
    .btn-success {
      background-color: var(--color-success);
      color: white;
    }
    
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-hover);
    }
    
    .btn:active {
      transform: translateY(0);
      box-shadow: var(--shadow-active);
    }
    
    .btn i {
      position: relative;
      z-index: 1;
    }
    
    .btn span {
      position: relative;
      z-index: 1;
    }
    
    .turno-sequence,
    .calendar-view {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      padding: 15px;
      background: linear-gradient(135deg, var(--color-background-alt) 0%, #ffffff 100%);
      border-radius: var(--radius);
      margin-bottom: 20px;
      border: 1px solid rgba(0,0,0,0.05);
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
      min-height: 80px;
    }
    
    .turno-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
      position: relative;
      animation: fadeInScale 0.3s ease-out;
    }
    
    @keyframes fadeInScale {
      from {
        opacity: 0;
        transform: scale(0.8);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }
    
    .turno-delete {
      position: absolute;
      top: -8px;
      right: -8px;
      width: 20px;
      height: 20px;
      background-color: var(--color-warning);
      color: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      cursor: pointer;
      z-index: 5;
      box-shadow: 0 2px 6px rgba(231, 76, 60, 0.4);
      transition: var(--transition-fast);
      opacity: 0.9;
    }
    
    .turno-delete:hover {
      transform: scale(1.2) rotate(90deg);
      opacity: 1;
      box-shadow: 0 3px 10px rgba(231, 76, 60, 0.5);
    }
    
    .turno-delete:active {
      transform: scale(0.95) rotate(90deg);
    }
    
    .turno-circle {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      font-size: 13px;
      cursor: pointer;
      box-shadow: 0 3px 8px rgba(0,0,0,0.15);
      transition: var(--transition);
      position: relative;
      overflow: hidden;
    }
    
    .turno-circle::after {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: linear-gradient(45deg, transparent, rgba(255,255,255,0.3), transparent);
      transform: translateX(-100%);
      transition: transform 0.6s;
    }
    
    .turno-circle:hover { 
      transform: scale(1.15) rotate(5deg);
      box-shadow: 0 5px 15px rgba(0,0,0,0.25);
    }
    
    .turno-circle:hover::after {
      transform: translateX(100%);
    }
    
    .turno-circle:active {
      transform: scale(1.05);
    }
    
    .turno-m { background-color: var(--color-morning); }
    .turno-t { background-color: var(--color-afternoon); }
    .turno-dd { background-color: var(--color-double); }
    .turno-fs { background-color: var(--color-success); }
    
    /* Turnos sugeridos */
    .sugerido {
      background-color: var(--bg-sugerido);
      border: 2px dashed var(--border-sugerido);
      padding: 6px;
      border-radius: var(--radius);
      animation: fadeIn 0.5s ease-out, glow 2s ease-in-out infinite;
    }
    
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: scale(0.8);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }
    
    @keyframes glow {
      0%, 100% {
        box-shadow: 0 0 5px rgba(240, 198, 116, 0.3);
      }
      50% {
        box-shadow: 0 0 15px rgba(240, 198, 116, 0.5);
      }
    }
    
    /* Flechas */
    .arrow {
      color: #bbb;
      font-size: 20px;
      transition: var(--transition-fast);
    }
    
    .turno-item:hover + .arrow,
    .arrow:hover {
      color: var(--color-primary);
      transform: translateX(3px);
    }
    
    .sugerido-arrow {
      color: var(--border-sugerido);
      font-weight: bold;
      font-size: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #fffdf0;
      padding: 5px 10px;
      border-radius: var(--radius);
      border: 2px dashed var(--border-sugerido);
      margin: 0 5px;
    }
    
    /* Indicadores de descanso */
    .descanso-indicator {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-width: 80px;
    }
    
    .descanso-hours { 
      font-weight: 700;
      font-size: 15px;
      color: var(--color-text);
    }
    
    .descanso-deficit { 
      color: #d32f2f;
      font-size: 12px;
      font-weight: 600;
      background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #ef5350;
      animation: pulse 2s ease-in-out infinite;
      box-shadow: 0 2px 6px rgba(211, 47, 47, 0.2);
    }
    
    .descanso-ok { 
      color: #2e7d32;
      font-size: 12px;
      font-weight: 600;
      background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #66bb6a;
      box-shadow: 0 2px 6px rgba(46, 125, 50, 0.15);
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    /* Resultados y recomendaciones */
    .results-container {
      background-color: var(--color-background);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 25px;
      margin-bottom: 30px;
      transition: opacity 0.3s ease, transform 0.3s ease;
      border: 1px solid rgba(0,0,0,0.05);
      animation: slideIn 0.4s ease-out;
    }
    
    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .results-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #eee;
    }
    
    .results-title {
      font-size: 18px;
      color: var(--color-primary);
    }
    
    .pattern-box {
      padding: 18px;
      border-radius: var(--radius);
      margin-bottom: 15px;
      border-left: 5px solid;
      transition: var(--transition);
      position: relative;
    }
    
    .pattern-box:hover {
      transform: translateX(2px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }
    
    .pattern-title {
      font-weight: bold;
      margin-bottom: 5px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .pattern-simple { background-color: var(--color-background-alt); border-left-color: var(--color-morning); }
    .pattern-double { background-color: #fff5f5; border-left-color: var(--color-afternoon); }
    .pattern-triple { background-color: #ffefef; border-left-color: var(--color-double); }
    .pattern-alternated { background-color: #f0fff4; border-left-color: var(--color-success); }
    
    .deficit-summary {
      display: flex;
      justify-content: space-between;
      margin: 20px 0;
    }
    
    .deficit-box {
      flex: 1;
      padding: 20px 15px;
      background: linear-gradient(135deg, var(--color-background-alt) 0%, white 100%);
      border-radius: var(--radius);
      text-align: center;
      margin: 0 10px;
      transition: var(--transition);
      border: 1px solid rgba(0,0,0,0.05);
      position: relative;
      overflow: hidden;
    }
    
    .deficit-box::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--color-primary), var(--color-primary-dark));
      transform: scaleX(0);
      transition: transform 0.3s ease;
    }
    
    .deficit-box:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 20px rgba(0,0,0,0.12);
      border-color: var(--color-primary);
    }
    
    .deficit-box:hover::before {
      transform: scaleX(1);
    }
    
    /* Estilo rojo para cuando hay d√©ficit */
    .deficit-box.has-deficit {
      background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
      border: 2px solid #ef5350;
      box-shadow: 0 4px 12px rgba(211, 47, 47, 0.2);
    }
    
    .deficit-box.has-deficit::before {
      background: linear-gradient(90deg, #d32f2f, #c62828);
    }
    
    .deficit-box.has-deficit:hover {
      box-shadow: 0 8px 25px rgba(211, 47, 47, 0.3);
      border-color: #d32f2f;
    }
    
    .deficit-number {
      font-size: 28px;
      font-weight: 700;
      margin-bottom: 8px;
      background: linear-gradient(135deg, var(--color-primary), var(--color-primary-dark));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .deficit-box.has-deficit .deficit-number {
      background: linear-gradient(135deg, #d32f2f, #c62828);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .deficit-label {
      font-size: 13px;
      color: var(--color-text-light);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-weight: 500;
    }
    
    .deficit-box.has-deficit .deficit-label {
      color: #c62828;
      font-weight: 600;
    }
    
    /* Recomendaciones */
    .recommendation-box {
      background: linear-gradient(135deg, var(--color-primary-light) 0%, #f0f8ff 100%);
      border-radius: var(--radius);
      padding: 22px;
      margin-bottom: 20px;
      border-left: 5px solid var(--color-primary);
      transition: opacity 0.3s ease, transform 0.3s ease;
      box-shadow: 0 2px 8px rgba(0, 120, 212, 0.1);
      animation: slideIn 0.5s ease-out;
    }
    
    .recommendation-title {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 16px;
      font-weight: bold;
      color: var(--color-primary);
      margin-bottom: 10px;
    }
    
    .compensation-options {
      margin-top: 15px;
    }
    
    .compensation-option {
      background-color: white;
      border-radius: var(--radius);
      padding: 16px;
      margin-bottom: 12px;
      border: 2px solid #eee;
      cursor: pointer;
      transition: var(--transition);
      position: relative;
      overflow: hidden;
    }
    
    .compensation-option::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      background: var(--color-success);
      transform: scaleY(0);
      transition: transform 0.3s ease;
    }
    
    .compensation-option:hover {
      transform: translateX(4px);
      box-shadow: var(--shadow);
      border-color: var(--color-primary);
    }
    
    .compensation-option:hover::before {
      transform: scaleY(1);
    }
    
    .compensation-option.selected {
      border: 2px solid var(--color-success);
      background: linear-gradient(135deg, #f0fff4 0%, white 100%);
      transform: translateX(4px);
      box-shadow: 0 5px 20px rgba(39,174,96,0.25);
    }
    
    .compensation-option.selected::before {
      transform: scaleY(1);
    }
    
    .option-title {
      font-weight: bold;
      margin-bottom: 5px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .option-description {
      font-size: 14px;
      color: var(--color-text-light);
    }
    
    /* Calendario Adaptado */
    .calendar-container {
      margin-top: 30px;
      transition: opacity 0.3s ease, transform 0.3s ease;
      animation: slideIn 0.6s ease-out;
    }
    
    .calendar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    
    .calendar-title {
      font-size: 18px;
      color: var(--color-primary);
    }
    
    .calendar-actions {
      display: flex;
      gap: 10px;
    }
    
    /* Tooltip */
    .info-tooltip {
      position: relative;
      display: inline-block;
      margin-left: 5px;
      font-size: 14px;
      color: var(--color-primary);
    }
    
    .info-tooltip .tooltip-text {
      visibility: hidden;
      width: 220px;
      background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
      color: #fff;
      text-align: center;
      border-radius: 8px;
      padding: 10px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -110px;
      opacity: 0;
      transition: opacity 0.3s, transform 0.3s;
      font-size: 12px;
      font-weight: normal;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
      transform: translateY(10px);
    }
    
    .info-tooltip .tooltip-text::after {
      content: "";
      position: absolute;
      top: 100%;
      left: 50%;
      margin-left: -5px;
      border-width: 5px;
      border-style: solid;
      border-color: #333 transparent transparent transparent;
    }
    
    .info-tooltip:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
      transform: translateY(0);
    }
    
    /* Modal */
    #turnoModal {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    #turnoModal > div {
      background-color: white;
      padding: 28px;
      border-radius: 16px;
      max-width: 480px;
      width: 100%;
      box-shadow: 0 10px 40px rgba(0,0,0,0.2);
      border: 1px solid rgba(0,0,0,0.1);
    }
    
    /* Mensaje de error/info */
    #info-messages {
      margin-bottom: 15px;
    }
    
    .message {
      padding: 10px 15px;
      border-radius: var(--radius);
      margin-bottom: 10px;
      font-size: 14px;
    }
    
    .message-info {
      background-color: #e3f2fd;
      border-left: 4px solid var(--color-primary);
    }
    
    .message-error {
      background-color: #ffebee;
      border-left: 4px solid var(--color-warning);
    }
    
    .message-success {
      background-color: #e8f5e9;
      border-left: 4px solid var(--color-success);
    }
    
    /* Media queries mejorados */
    @media print {
      body { background: white; }
      .container { box-shadow: none; max-width: 100%; }
      .tabs, .turnos-control, .btn, .add-turno-circle, .turno-delete { 
        display: none !important; 
      }
      header { 
        background: white !important; 
        color: black !important; 
        padding: 15px; 
      }
      .tab-content { 
        display: block !important; 
        padding: 10px;
      }
      .turno-sequence, .calendar-view {
        page-break-inside: avoid;
      }
    }
    
    @media (max-width: 768px) {
      .container { 
        margin: 0; 
        border-radius: 0;
      }
      .turnos-titulo { 
        flex-direction: column; 
        align-items: flex-start; 
        gap: 10px; 
      }
      .turnos-control { 
        width: 100%; 
        justify-content: space-between; 
      }
      .deficit-summary { 
        flex-direction: column; 
        gap: 10px; 
      }
      .deficit-box { 
        margin: 0 0 10px 0; 
      }
      #turnoModal > div {
        width: 90%;
        padding: 15px;
      }
    }
    
    @media (max-width: 480px) {
      body {
        padding: 10px;
      }
      .turno-sequence, .calendar-view {
        padding: 10px 5px;
      }
      .btn {
        padding: 6px 12px;
        font-size: 13px;
      }
    }

    /* ======== ESTILOS PARA COMPROBACI√ìN DE HORARIOS ======== */
    
    /* Instrucciones */
    .instrucciones-box {
      background: linear-gradient(135deg, #e3f2fd 0%, #f0f8ff 100%);
      border-radius: var(--radius);
      padding: 12px 15px;
      margin-bottom: 15px;
      border-left: 4px solid var(--color-primary);
      box-shadow: 0 2px 8px rgba(0, 120, 212, 0.1);
    }
    
    .instrucciones-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      font-weight: bold;
      color: var(--color-primary);
      margin-bottom: 8px;
    }
    
    .instrucciones-content {
      font-size: 11px;
      color: var(--color-text);
      line-height: 1.5;
    }
    
    .instrucciones-content ol {
      margin: 6px 0 6px 18px;
    }
    
    .instrucciones-content li {
      margin-bottom: 4px;
    }
    
    /* Controles */
    .check-controls {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }
    
    .check-controls .btn {
      padding: 6px 12px;
      font-size: 11px;
    }
    
    /* Tabla Editable */
    .tabla-container {
      background: white;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      margin-bottom: 20px;
      overflow: hidden;
    }
    
    .tabla-scroll {
      overflow-x: auto;
      max-width: 100%;
    }
    
    @media (min-width: 1280px) {
      .tabla-scroll {
        overflow-x: visible;
      }
    }
    
    .tabla-editable {
      width: 100%;
      border-collapse: collapse;
      font-size: 9px;
    }
    
    .tabla-editable thead {
      background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
      color: white;
    }
    
    .tabla-editable th {
      padding: 4px 2px;
      text-align: center;
      font-weight: 600;
      border-right: 1px solid rgba(255,255,255,0.2);
      min-width: 30px;
      max-width: 30px;
      font-size: 9px;
    }
    
    .tabla-editable th:first-child {
      min-width: 70px;
      max-width: 70px;
      position: sticky;
      left: 0;
      z-index: 10;
      background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
      text-align: left;
      padding-left: 6px;
      font-size: 9px;
    }
    
    .tabla-editable tbody tr {
      border-bottom: 2px solid transparent;
      transition: background-color 0.2s ease;
    }
    
    .tabla-editable tbody tr:hover {
      background-color: #f8f9fa;
    }
    
    .tabla-editable td {
      padding: 6px 2px;
      border: 1px solid #e0e0e0;
      min-height: 24px;
      cursor: text;
      font-size: 9px;
    }
    
    .tabla-editable td:first-child {
      font-weight: 500;
      background: white;
      position: sticky;
      left: 0;
      z-index: 5;
      min-width: 70px;
      max-width: 70px;
      padding-left: 6px;
      font-size: 9px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .tabla-editable td.col-turno {
      text-align: center;
      vertical-align: middle;
      font-weight: 600;
      font-size: 9px;
      text-transform: uppercase;
      position: relative;
      min-width: 30px;
      max-width: 30px;
      padding: 6px 2px;
    }
    
    .tabla-editable td:focus {
      outline: 2px solid var(--color-primary);
      outline-offset: -2px;
      background-color: #fff9e6;
    }
    
    /* Marcado de d√©ficits - BLOQUES VISUALMENTE UNIDOS CON TRANSPARENCIA */
    .tabla-editable td.deficit {
      background: rgba(244, 67, 54, 0.35);
      color: #c62828;
      font-weight: 700;
      border: 4px solid #ef5350 !important;
      box-shadow: 0 0 0 2px rgba(244, 67, 54, 0.2), 0 2px 6px rgba(183, 28, 28, 0.25);
      position: relative;
      cursor: help;
      transition: all 0.2s ease;
    }
    
    /* Clase para marcar el inicio de un bloque de d√©ficit */
    .tabla-editable td.deficit-bloque-inicio + td.deficit-bloque-fin {
      border-left: none !important;
    }
    
    .tabla-editable td.deficit-bloque-inicio:has(+ td.deficit-bloque-fin) {
      border-right: none !important;
    }
    
    .tabla-editable td.deficit:hover {
      background: rgba(244, 67, 54, 0.5);
      box-shadow: 0 0 0 2px rgba(244, 67, 54, 0.3), 0 3px 8px rgba(183, 28, 28, 0.35);
      transform: scale(1.05);
      z-index: 100;
    }
    
    .tabla-editable td.compensado {
      background: rgba(229, 115, 115, 0.35);
      color: #d32f2f;
      font-weight: 600;
      border: 3px solid #e57373;
      box-shadow: 0 0 0 1px rgba(229, 115, 115, 0.2), 0 1px 4px rgba(198, 40, 40, 0.2);
      cursor: help;
      transition: all 0.2s ease;
    }
    
    /* Clase para marcar el inicio de un bloque de compensado */
    .tabla-editable td.compensado-bloque-inicio + td.compensado-bloque-fin {
      border-left: none !important;
    }
    
    .tabla-editable td.compensado-bloque-inicio:has(+ td.compensado-bloque-fin) {
      border-right: none !important;
    }
    
    .tabla-editable td.compensado:hover {
      background: rgba(229, 115, 115, 0.5);
      box-shadow: 0 0 0 1px rgba(229, 115, 115, 0.3), 0 2px 6px rgba(198, 40, 40, 0.3);
      transform: scale(1.05);
      z-index: 100;
    }
    
    .tabla-editable td.ok {
      background: #f5f5f5;
      color: #666;
    }
    
    .tabla-editable td.fs-dia {
      background: transparent;
      color: #9575CD;
      font-weight: 600;
      border: none;
    }
    
    .tabla-editable td.fs-dia:hover {
      color: #7E57C2;
      transform: scale(1.05);
      z-index: 100;
    }
    
    /* Flecha sutil entre transiciones con d√©ficit */
    .flecha-deficit {
      position: absolute;
      right: -8px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 16px;
      z-index: 50;
      display: flex;
      align-items: center;
      justify-content: center;
      background: white;
      border-radius: 50%;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);
    }
    
    .flecha-deficit::before {
      content: '‚Üí';
      color: #c62828;
      font-size: 12px;
      font-weight: bold;
      line-height: 1;
    }
    
    .flecha-deficit.compensado::before {
      color: #ef5350;
    }
    
    /* Tooltip flotante para informaci√≥n de descanso */
    .tooltip-descanso {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%) translateY(-5px);
      background: #333;
      color: white;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 10px;
      white-space: nowrap;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s ease, visibility 0.2s ease;
      pointer-events: none;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    
    .tooltip-descanso::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 5px solid transparent;
      border-top-color: #333;
    }
    
    .tabla-editable td.deficit:hover .tooltip-descanso,
    .tabla-editable td.compensado:hover .tooltip-descanso {
      opacity: 1;
      visibility: visible;
    }
    
    .tooltip-descanso.deficit {
      background: #c62828;
      box-shadow: 0 2px 8px rgba(198, 40, 40, 0.5);
    }
    
    .tooltip-descanso.deficit::after {
      border-top-color: #c62828;
    }
    
    .tooltip-descanso.compensado {
      background: #ef5350;
    }
    
    .tooltip-descanso.compensado::after {
      border-top-color: #ef5350;
    }
    
    .tooltip-linea {
      display: block;
      margin: 2px 0;
    }
    
    .tooltip-linea strong {
      font-weight: 700;
    }
    
    /* Resultados */
    .resultados-header {
      margin: 30px 0 20px 0;
      padding-bottom: 10px;
      border-bottom: 2px solid var(--color-primary);
    }
    
    .resultados-header h3 {
      color: var(--color-primary);
      font-size: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    /* Resumen General */
    .resumen-box {
      background: linear-gradient(135deg, #f0f8ff 0%, #e3f2fd 100%);
      border-radius: var(--radius);
      padding: 20px;
      margin-bottom: 25px;
      border-left: 5px solid var(--color-primary);
      box-shadow: 0 2px 8px rgba(0, 120, 212, 0.1);
    }
    
    .resumen-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 15px;
    }
    
    .stat-card {
      background: white;
      padding: 15px;
      border-radius: var(--radius);
      text-align: center;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
      transition: transform 0.2s ease;
    }
    
    .stat-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.12);
    }
    
    .stat-number {
      font-size: 32px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .stat-label {
      font-size: 13px;
      color: var(--color-text-light);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .stat-card.success .stat-number {
      color: var(--color-success);
    }
    
    .stat-card.warning .stat-number {
      color: var(--color-warning);
    }
    
    .stat-card.info .stat-number {
      color: var(--color-primary);
    }
    
    /* Informes Individuales */
    #informes-individuales {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    
    .informe-trabajador {
      background: white;
      border-radius: var(--radius);
      padding: 20px;
      box-shadow: var(--shadow);
      border-left: 5px solid #bdbdbd;
      transition: all 0.3s ease;
    }
    
    .informe-trabajador.con-deficit {
      border-left-color: var(--color-warning);
    }
    
    .informe-trabajador.sin-deficit {
      border-left-color: var(--color-success);
    }
    
    .informe-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #e0e0e0;
    }
    
    .informe-nombre {
      font-size: 18px;
      font-weight: bold;
      color: var(--color-text);
    }
    
    .informe-badge {
      padding: 6px 14px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
    }
    
    .informe-badge.success {
      background: #e8f5e9;
      color: var(--color-success);
    }
    
    .informe-badge.warning {
      background: #ffebee;
      color: var(--color-warning);
    }
    
    .btn-exportar-informe {
      padding: 4px 10px;
      border: none;
      border-radius: 4px;
      background: #2e7d32;
      color: white;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      display: inline-flex;
      align-items: center;
      gap: 5px;
    }
    
    .btn-exportar-informe:hover {
      background: #1b5e20;
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .btn-exportar-informe:active {
      transform: translateY(0);
    }
    
    .btn-exportar-informe i {
      font-size: 12px;
    }
    
    .informe-detalles {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
      margin-bottom: 15px;
    }
    
    .informe-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
    }
    
    .informe-item i {
      color: var(--color-primary);
    }
    
    .informe-deficits {
      margin-top: 15px;
      padding: 12px;
      background: #fff9e6;
      border-radius: var(--radius);
      border-left: 3px solid #ffd54f;
    }
    
    .informe-deficits-title {
      font-weight: bold;
      margin-bottom: 8px;
      color: #f57f17;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .deficit-list {
      font-size: 13px;
      color: var(--color-text);
      line-height: 1.6;
    }
    
    /* Responsive para tabla */
    @media (max-width: 768px) {
      .check-controls {
        flex-direction: column;
      }
      
      .check-controls .btn {
        width: 100%;
      }
      
      .tabla-editable th,
      .tabla-editable td {
        min-width: 35px;
        padding: 5px 2px;
        font-size: 9px;
      }
      
      .tabla-editable th:first-child,
      .tabla-editable td:first-child {
        min-width: 70px;
        font-size: 9px;
      }
      
      .tabla-editable td.col-turno {
        min-width: 35px;
        max-width: 35px;
        padding: 5px 2px;
        font-size: 9px;
      }
      
      .tooltip-descanso {
        font-size: 9px;
        padding: 4px 8px;
      }
      
      .flecha-deficit {
        width: 14px;
        height: 14px;
        right: -7px;
      }
      
      .flecha-deficit::before {
        font-size: 10px;
      }
      
      .resumen-stats {
        grid-template-columns: 1fr;
      }
      
      .informe-detalles {
        grid-template-columns: 1fr;
      }
      
      .btn-exportar-informe {
        padding: 6px 12px;
        font-size: 10px;
      }
      
      .informe-header {
        flex-direction: column;
        align-items: flex-start !important;
        gap: 10px;
      }
    }
    
    /* Animaciones para feedback de deshacer/rehacer */
    @keyframes slideInRight {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    @keyframes fadeOut {
      from {
        opacity: 1;
      }
      to {
        opacity: 0;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Calculadora de descansos entre jornades</h1>
      <div class="subheader">Sistema d'an√†lisi i compensaci√≥ de descansos en torns sanitaris</div>
    </header>

    <!-- Pesta√±as -->
    <div class="tabs">
      <div class="tab active" data-tab="calculadora">Calculadora</div>
      <div class="tab" data-tab="comprobacion">Comprovaci√≥ d'horaris</div>
    </div>

    <!-- CALCULADORA -->
    <div class="tab-content active" id="calculadora">
      <div id="info-messages"></div>
      <div class="turnos-container">
        <div class="turnos-titulo">
          <h2>Seq√º√®ncia de torns 
            <span class="info-tooltip">
              <i class="fas fa-info-circle"></i>
              <span class="tooltip-text">Afegeix els torns en ordre cronol√≤gic per analitzar el descans entre ells</span>
            </span>
          </h2>
          <div class="turnos-control">
            <button class="btn btn-primary" id="add-turno">
              <i class="fas fa-plus"></i> <span>Afegir Torn</span>
            </button>
            <button class="btn btn-secondary" id="clear-turnos">
              <i class="fas fa-trash"></i> <span>Netejar</span>
            </button>
          </div>
        </div>
        <div class="turno-sequence" id="turno-sequence">
          <!-- Turnos se agregan din√°micamente -->
        </div>
      </div>

      <!-- Resultados -->
      <div class="results-container" id="results" style="display: none;">
        <div class="results-header">
          <div class="results-title">An√†lisi de descansos</div>
        </div>
        <div class="pattern-box pattern-double" id="pattern-box">
          <div class="pattern-title">
            <i class="fas fa-exclamation-triangle"></i> <strong>Patr√≥ Detectat:</strong> <span id="pattern-name">D√®ficit doble</span>
          </div>
          <p id="pattern-description"></p>
        </div>
        <div class="deficit-summary">
          <div class="deficit-box">
            <div class="deficit-number" id="deficit-total">0:00</div>
            <div class="deficit-label"><strong>D√®ficit Total</strong></div>
          </div>
          <div class="deficit-box">
            <div class="deficit-number" id="compensacion-requerida">0:00</div>
            <div class="deficit-label"><strong>Compensaci√≥ Requerida</strong></div>
          </div>
          <div class="deficit-box">
            <div class="deficit-number" id="transiciones-deficitarias">0</div>
            <div class="deficit-label"><strong>Transicions Deficit√†ries</strong></div>
          </div>
        </div>
      </div>

      <!-- Recomendaciones -->
      <div class="recommendation-box" id="recommendations" style="display: none;">
        <div class="recommendation-title">
          <i class="fas fa-lightbulb"></i> Recomanacions de compensaci√≥
        </div>
        <p id="recommendation-text"></p>
        <div class="compensation-options" id="compensation-options">
          <!-- Opciones de compensaci√≥n generadas din√°micamente -->
        </div>
      </div>

      <!-- Calendario Adaptado -->
      <div class="calendar-container" id="calendar" style="display: none;">
        <div class="calendar-header">
          <div class="calendar-title">Horari adaptat amb compensaci√≥</div>
        </div>
        <div class="calendar-view" id="calendar-view">
          <!-- Se muestra la secuencia original + recomendaci√≥n o mensaje -->
        </div>
      </div>
    </div>

    <!-- COMPROBACI√ìN DE HORARIOS -->
    <div class="tab-content" id="comprobacion">
      <div id="info-messages-check"></div>
      
      <!-- Instrucciones -->
      <div class="instrucciones-box">
        <div class="instrucciones-title">
          <i class="fas fa-info-circle"></i> Com utilitzar aquesta eina
        </div>
        <div class="instrucciones-content">
          <ol>
            <li><strong>Copia</strong> les dades des d'Excel (fins a 31 dies)</li>
            <li><strong>Enganxa</strong> directament a la taula o edita manualment</li>
            <li><strong>Prem "Revisar Horaris"</strong> per analitzar els descansos</li>
            <li>Els torns amb <span style="color: var(--color-warning); font-weight: bold;">d√®ficit</span> es marcaran en vermell</li>
          </ol>
          <div style="margin-top: 6px; padding: 6px; background: #fff3cd; border-radius: 4px; font-size: 10px;">
            <strong>Format:</strong> Nom + D1...D31 (editable) | Treballador + torns (M, T, DD, FS)
          </div>
          <div style="margin-top: 6px; padding: 6px; background: #e3f2fd; border-radius: 4px; font-size: 10px; border-left: 3px solid #2196f3;">
            <strong>üí° Consell:</strong> Utilitza <kbd style="background: white; padding: 2px 5px; border-radius: 3px; border: 1px solid #ccc;">Ctrl+Z</kbd> per desfer i <kbd style="background: white; padding: 2px 5px; border-radius: 3px; border: 1px solid #ccc;">Ctrl+Y</kbd> per refer els canvis a la taula
          </div>
        </div>
      </div>

      <!-- Controles -->
      <div class="check-controls">
        <button class="btn btn-primary" id="btn-revisar-horarios">
          <i class="fas fa-search"></i> Revisar Horaris
        </button>
        <button class="btn btn-success" id="btn-copiar-tabla" style="display: none;">
          <i class="fas fa-copy"></i> Copiar Taula amb Format
        </button>
        <button class="btn btn-secondary" id="btn-limpiar-tabla">
          <i class="fas fa-eraser"></i> Netejar Taula
        </button>
        <button class="btn btn-success" id="btn-afegir-fila">
          <i class="fas fa-plus"></i> Afegir Fila
        </button>
      </div>

      <!-- Tabla Editable -->
      <div class="tabla-container">
        <div class="tabla-scroll">
          <table id="tabla-horarios" class="tabla-editable">
            <thead>
              <tr>
                <th contenteditable="true">Nom</th>
                <th contenteditable="true">D1</th>
                <th contenteditable="true">D2</th>
                <th contenteditable="true">D3</th>
                <th contenteditable="true">D4</th>
                <th contenteditable="true">D5</th>
                <th contenteditable="true">D6</th>
                <th contenteditable="true">D7</th>
                <th contenteditable="true">D8</th>
                <th contenteditable="true">D9</th>
                <th contenteditable="true">D10</th>
                <th contenteditable="true">D11</th>
                <th contenteditable="true">D12</th>
                <th contenteditable="true">D13</th>
                <th contenteditable="true">D14</th>
                <th contenteditable="true">D15</th>
                <th contenteditable="true">D16</th>
                <th contenteditable="true">D17</th>
                <th contenteditable="true">D18</th>
                <th contenteditable="true">D19</th>
                <th contenteditable="true">D20</th>
                <th contenteditable="true">D21</th>
                <th contenteditable="true">D22</th>
                <th contenteditable="true">D23</th>
                <th contenteditable="true">D24</th>
                <th contenteditable="true">D25</th>
                <th contenteditable="true">D26</th>
                <th contenteditable="true">D27</th>
                <th contenteditable="true">D28</th>
                <th contenteditable="true">D29</th>
                <th contenteditable="true">D30</th>
                <th contenteditable="true">D31</th>
              </tr>
            </thead>
            <tbody id="tabla-body">
              <tr>
                <td contenteditable="true" class="col-nombre"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
                <td contenteditable="true" class="col-turno"></td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- Resultados de An√°lisis -->
      <div id="resultados-comprobacion" style="display: none;">
        <div class="resultados-header">
          <h3><i class="fas fa-chart-bar"></i> Resultats de l'An√†lisi</h3>
        </div>
        
        <!-- Resumen General -->
        <div id="resumen-general" class="resumen-box">
          <!-- Se llenar√° din√°micamente -->
        </div>

        <!-- Informes Individuales -->
        <div id="informes-individuales">
          <!-- Se llenar√° din√°micamente con los informes de cada trabajador -->
        </div>
      </div>
    </div>
  </div>

  <!-- Modal para seleccionar turno -->
  <div id="turnoModal">
    <div>
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h3 style="margin: 0; font-size: 20px; color: var(--color-primary);">Seleccionar Torn</h3>
        <div onclick="closeModal()" style="cursor: pointer; font-size: 18px; color: #6c757d;">
          <i class="fas fa-times"></i>
        </div>
      </div>
      <div style="display: flex; gap: 12px; margin-bottom: 25px; flex-wrap: wrap;">
        <div onclick="addTurnoType('M')" data-tipo="M" class="modal-turno-card" style="flex: 1; padding: 22px 15px; text-align: center; background: linear-gradient(135deg, var(--color-morning) 0%, #2980b9 100%); color: white; border-radius: 12px; cursor: pointer; box-shadow: 0 4px 12px rgba(52,152,219,0.3); min-width: 85px; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); position: relative; overflow: hidden;">
          <div style="font-size: 32px; margin-bottom: 8px; font-weight: 700;">M</div>
          <div style="font-weight: 600; margin-bottom: 4px; font-size: 15px;">Mat√≠</div>
          <div style="font-size: 11px; opacity: 0.9;">7:30-14:45</div>
        </div>
        <div onclick="addTurnoType('T')" data-tipo="T" class="modal-turno-card" style="flex: 1; padding: 22px 15px; text-align: center; background: linear-gradient(135deg, var(--color-afternoon) 0%, #c0392b 100%); color: white; border-radius: 12px; cursor: pointer; box-shadow: 0 4px 12px rgba(231,76,60,0.3); min-width: 85px; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); position: relative; overflow: hidden;">
          <div style="font-size: 32px; margin-bottom: 8px; font-weight: 700;">T</div>
          <div style="font-weight: 600; margin-bottom: 4px; font-size: 15px;">Tarda</div>
          <div style="font-size: 11px; opacity: 0.9;">14:30-21:45</div>
        </div>
        <div onclick="addTurnoType('DD')" data-tipo="DD" class="modal-turno-card" style="flex: 1; padding: 22px 15px; text-align: center; background: linear-gradient(135deg, var(--color-double) 0%, #8e44ad 100%); color: white; border-radius: 12px; cursor: pointer; box-shadow: 0 4px 12px rgba(155,89,182,0.3); min-width: 85px; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); position: relative; overflow: hidden;">
          <div style="font-size: 32px; margin-bottom: 8px; font-weight: 700;">DD</div>
          <div style="font-weight: 600; margin-bottom: 4px; font-size: 15px;">Doblatge</div>
          <div style="font-size: 11px; opacity: 0.9;">7:30-21:45</div>
        </div>
        <div onclick="addTurnoType('FS')" data-tipo="FS" class="modal-turno-card" style="flex: 1; padding: 22px 15px; text-align: center; background: linear-gradient(135deg, var(--color-success) 0%, #229954 100%); color: white; border-radius: 12px; cursor: pointer; box-shadow: 0 4px 12px rgba(39,174,96,0.3); min-width: 85px; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); position: relative; overflow: hidden;">
          <div style="font-size: 32px; margin-bottom: 8px; font-weight: 700;">FS</div>
          <div style="font-weight: 600; margin-bottom: 4px; font-size: 15px;">Dia Lliure</div>
          <div style="font-size: 11px; opacity: 0.9;">24h</div>
        </div>
      </div>
      <style>
        .modal-turno-card::before {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, transparent 100%);
          opacity: 0;
          transition: opacity 0.3s ease;
        }
        .modal-turno-card:hover {
          transform: translateY(-5px) scale(1.05);
          box-shadow: 0 8px 25px rgba(0,0,0,0.25) !important;
        }
        .modal-turno-card:hover::before {
          opacity: 1;
        }
        .modal-turno-card:active {
          transform: translateY(-2px) scale(1.02);
        }
      </style>
    </div>
  </div>
  <script>
    /* ======== VARIABLES DE ESTADO ======== */
    let turnos = [];
    let currentDeficitMinutes = 0;
    let deficitsDetallados = [];
    let ultimoAnalisis = null; // Para almacenar el √∫ltimo an√°lisis completo y evitar rec√°lculos
    
    // Referencias a elementos DOM (centralizadas para mejor mantenimiento)
    const elementos = {
      turnoSequence: document.getElementById('turno-sequence'),
      turnoModal: document.getElementById('turnoModal'),
      resultsSection: document.getElementById('results'),
      recommendationsSection: document.getElementById('recommendations'),
      calendarSection: document.getElementById('calendar'),
      calendarView: document.getElementById('calendar-view'),
      infoMessages: document.getElementById('info-messages'),
      btnAddTurno: document.getElementById('add-turno'),
      btnClearTurnos: document.getElementById('clear-turnos'),
      deficitTotal: document.getElementById('deficit-total'),
      compensacionRequerida: document.getElementById('compensacion-requerida'),
      transicionesDeficitarias: document.getElementById('transiciones-deficitarias'),
      patternBox: document.getElementById('pattern-box'),
      patternName: document.getElementById('pattern-name'),
      patternDescription: document.getElementById('pattern-description'),
      recommendationText: document.getElementById('recommendation-text'),
      compensationOptions: document.getElementById('compensation-options')
    };

    /* ======== CONFIGURACI√ìN FIJA ======== */
    const config = {
      // Tiempos en minutos
      descansoReglamentario: 12 * 60, // 12 horas en minutos
      descansoMinimo: 7 * 60,         // 7 horas en minutos (m√≠nimo legal)
      diasCompensacion: 3,            // D√≠as m√°ximos para compensar d√©ficit
      minutosDia: 24 * 60,            // Minutos en un d√≠a (para c√°lculos)
      
      // Horarios de turnos (formato 24h)
      horarios: {
        'M': { 
          inicio: '07:30', 
          fin: '14:45',
          duracion: 7 * 60 + 15   // 7h15m en minutos
        },
        'T': { 
          inicio: '14:30', 
          fin: '21:45',
          duracion: 7 * 60 + 15   // 7h15m en minutos
        },
        'DD': { 
          inicio: '07:30', 
          fin: '21:45',
          duracion: 14 * 60 + 15  // 14h15m en minutos
        },
        'FS': {
          inicio: '00:00',
          fin: '23:59',
          duracion: 24 * 60       // 24h en minutos (d√≠a completo)
        }
      },
      
      // Mensajes de error/info
      mensajes: {
        errorGenerico: "Ha ocorregut un error. Si us plau, torna-ho a intentar.",
        limpieza: "S'ha netejat la seq√º√®ncia de torns.",
        sinDeficit: "No hi ha d√®ficit en la seq√º√®ncia actual.",
        deficitDetectado: "S'ha detectat d√®ficit en la seq√º√®ncia de torns.",
        transicionInvalida: "Atenci√≥: La transici√≥ entre aquests torns no √©s habitual en la pr√†ctica."
      }
    };

    /* ======== FUNCIONES DE UTILIDAD Y FORMATEO ======== */
    /**
     * Convierte una duraci√≥n en minutos a formato "horas:minutos"
     * @param {number} minutos - Minutos a formatear
     * @returns {string} Tiempo formateado (hh:mm)
     */
    function formatDuration(minutos) {
      if (isNaN(minutos)) return "0:00";
      
      const isNegative = minutos < 0;
      const absMinutos = Math.abs(minutos);
      const hours = Math.floor(absMinutos / 60);
      const minutes = Math.round(absMinutos % 60);
      
      return (isNegative ? "-" : "") + 
             hours + ":" + 
             (minutes < 10 ? "0" : "") + minutes;
    }

    /**
     * Convierte un string de tiempo (HH:MM) a minutos
     * @param {string} timeStr - Hora en formato HH:MM
     * @returns {number} Tiempo en minutos
     */
    function convertToMinutes(timeStr) {
      if (!timeStr || typeof timeStr !== 'string') return 0;
      
      try {
        const [h, m] = timeStr.split(':').map(num => parseInt(num, 10));
        
        if (isNaN(h) || isNaN(m)) return 0;
        
        return h * 60 + m;
      } catch (error) {
        console.error("Error al convertir tiempo a minutos:", error);
        return 0;
      }
    }

    /**
 * Muestra un mensaje informativo al usuario
 * @param {string} mensaje - Texto del mensaje
 * @param {string} tipo - Tipo de mensaje (info, error, success)
 * @param {number} duracion - Duraci√≥n en ms (0 para no auto-cerrar)
 */
function mostrarMensaje(mensaje, tipo = 'info', duracion = 5000) {
  return; // Funci√≥n desactivada - no muestra ning√∫n mensaje
}

    /**
     * Comprueba si una secuencia de turnos es v√°lida y segura
     * @param {array} secuencia - Array de turnos a validar
     * @returns {object} Resultado de la validaci√≥n {valido, mensaje}
     */
    function validarSecuenciaTurnos(secuencia) {
      if (!secuencia || !Array.isArray(secuencia) || secuencia.length < 2) {
        return { valido: true, mensaje: "" }; // No hay suficientes turnos para validar
      }
      
      // Validar transiciones peligrosas (DD seguido de M)
      for (let i = 0; i < secuencia.length - 1; i++) {
        if (secuencia[i] === 'DD' && secuencia[i+1] === 'M') {
          return { 
            valido: false, 
            mensaje: "Atenci√≥: La transici√≥ de Doblatge (DD) a Mat√≠ (M) pot ser perillosa per l'esc√†s descans." 
          };
        }
      }
      
      // M√°s validaciones podr√≠an a√±adirse aqu√≠
      
      return { valido: true, mensaje: "" };
    }

    /**
     * Calcula el tiempo de descanso entre dos turnos en minutos
     * @param {string} turnoActual - Tipo del turno actual
     * @param {string} turnoSiguiente - Tipo del turno siguiente
     * @returns {number} Minutos de descanso entre turnos
     */
    function calcularDescansoEnMinutos(turnoActual, turnoSiguiente) {
      // Si alguno es d√≠a libre, no hay d√©ficit
      if (turnoActual === 'FS' || turnoSiguiente === 'FS') {
        return config.minutosDia; // Retornamos el equivalente a un d√≠a completo
      }
      
      const finActual = convertToMinutes(config.horarios[turnoActual].fin);
      const inicioSiguiente = convertToMinutes(config.horarios[turnoSiguiente].inicio);
      
      // Si el inicio del siguiente es antes que el fin del actual, a√±adimos un d√≠a
      let minutos = (inicioSiguiente < finActual)
        ? (inicioSiguiente + config.minutosDia - finActual)
        : (inicioSiguiente - finActual);
        
      return minutos;
    }

    /**
     * Calcula el tiempo de descanso entre dos turnos en formato HH:MM
     * @param {string} turnoActual - Tipo del turno actual
     * @param {string} turnoSiguiente - Tipo del turno siguiente
     * @returns {string} Tiempo de descanso formateado
     */
    function calcularDescanso(turnoActual, turnoSiguiente) {
      const minutos = calcularDescansoEnMinutos(turnoActual, turnoSiguiente);
      return formatDuration(minutos);
    }

    /* ======== GESTI√ìN DE PESTA√ëAS ======== */
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', function() {
        // Desactivar todas las pesta√±as
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        
        // Activar pesta√±a seleccionada
        this.classList.add('active');
        
        // Desactivar todos los contenidos de pesta√±as
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
        
        // Activar contenido relacionado con la pesta√±a
        const tabId = this.getAttribute('data-tab');
        const targetContent = document.getElementById(tabId);
        
        if (targetContent) {
          targetContent.classList.add('active');
        } else {
          console.error(`Contenido de pesta√±a no encontrado: ${tabId}`);
        }
      });
    });

    /* ======== INICIALIZACI√ìN DE BOTONES ======== */
    // Asignaci√≥n de eventos con manejo de errores
    try {
      // A√±adir turno
      elementos.btnAddTurno.addEventListener('click', () => {
        try {
          showModal();
        } catch (error) {
          console.error("Error al mostrar modal:", error);
          mostrarMensaje("No s'ha pogut mostrar el selector de torns", "error");
        }
      });
      
      // Limpiar turnos
      elementos.btnClearTurnos.addEventListener('click', () => {
        try {
          turnos = [];
          deficitsDetallados = [];
          ultimoAnalisis = null;
          elementos.turnoSequence.innerHTML = '';
          hideResults();
          mostrarMensaje("S'ha netejat la seq√º√®ncia de torns", "info");
        } catch (error) {
          console.error("Error al limpiar turnos:", error);
          mostrarMensaje("No s'han pogut netejar els torns", "error");
        }
      });
    } catch (error) {
      console.error("Error en la inicializaci√≥n de botones:", error);
    }
  </script>
  <script>
    /* ======== A√ëADIR Y ELIMINAR TURNOS ======== */
    /**
     * A√±ade un nuevo turno a la secuencia
     * @param {string} tipo - Tipo de turno (M, T, DD, FS)
     */
    function addTurnoType(tipo) {
      try {
        // Validar el tipo de turno
        if (!['M', 'T', 'DD', 'FS'].includes(tipo)) {
          throw new Error(`Tipo de turno no v√°lido: ${tipo}`);
        }
        
        // A√±adir a la secuencia
        turnos.push(tipo);
        
        // Cerrar modal y actualizar vista
        closeModal();
        renderTurnos();
        
        // Si hay suficientes turnos, analizar la secuencia
        if (turnos.length > 1) {
          // Validar la secuencia antes de analizar
          const validacion = validarSecuenciaTurnos(turnos);
          if (!validacion.valido) {
            mostrarMensaje(validacion.mensaje, "error", 0);
          }
          analyzeSequence();
        } else {
          hideResults();
        }
      } catch (error) {
        console.error("Error al a√±adir turno:", error);
        closeModal();
        mostrarMensaje("Error en afegir torn. Si us plau, torna-ho a intentar.", "error");
        
        // Asegurar que la interfaz est√© actualizada
        renderTurnos();
      }
    }

    /**
     * Elimina un turno de la secuencia
     * @param {number} index - √çndice del turno a eliminar
     */
    function removeTurno(index) {
      try {
        // Validar √≠ndice
        if (index < 0 || index >= turnos.length) {
          throw new Error(`√çndice fuera de rango: ${index}`);
        }
        
        // Eliminar de la secuencia
        turnos.splice(index, 1);
        
        // Actualizar vista y an√°lisis
        renderTurnos();
        
        // Limpiar an√°lisis anterior
        ultimoAnalisis = null;
        
        if (turnos.length > 1) {
          analyzeSequence();
        } else {
          hideResults();
          mostrarMensaje("Es necessiten almenys dos torns per calcular descansos.", "info");
        }
      } catch (error) {
        console.error("Error al eliminar turno:", error);
        mostrarMensaje("No s'ha pogut eliminar el torn.", "error");
        
        // Intentar recuperar un estado v√°lido
        renderTurnos();
      }
    }

    /* ======== RENDERIZAR LA SECUENCIA DE TURNOS ======== */
    /**
     * Renderiza la secuencia de turnos en la interfaz
     */
    function renderTurnos() {
      try {
        // Limpiar contenedor
        elementos.turnoSequence.innerHTML = '';
        
        // Si no hay turnos, mostrar bot√≥n de a√±adir directamente
        if (turnos.length === 0) {
          const addFirstTurnoBtn = document.createElement('div');
          addFirstTurnoBtn.className = 'turno-item';
          addFirstTurnoBtn.style.cursor = 'pointer';
          
          const addCircle = document.createElement('div');
          addCircle.className = 'turno-circle';
          addCircle.style.backgroundColor = '#ddd';
          addCircle.style.color = '#333';
          addCircle.textContent = '+';
          addCircle.style.fontSize = '28px';
          addCircle.style.fontWeight = 'bold';
          addCircle.addEventListener('click', showModal);
          addFirstTurnoBtn.appendChild(addCircle);

          const addLabel = document.createElement('div');
          addLabel.style.fontSize = '12px';
          addLabel.style.color = '#666';
          addLabel.style.fontWeight = '500';
          addLabel.textContent = 'Afegir torn';
          addFirstTurnoBtn.appendChild(addLabel);

          elementos.turnoSequence.appendChild(addFirstTurnoBtn);
          return;
        }
        
        // Calcular d√©ficits y compensaciones para toda la secuencia
        const analisisCompleto = calcularDeficitConCompensacion(turnos);
        const deficitsOriginales = analisisCompleto.deficitsOriginales || [];
        
        // Renderizar cada turno
        turnos.forEach((turno, index) => {
          // Crear contenedor de turno
          const turnoItem = document.createElement('div');
          turnoItem.className = 'turno-item';

          // Bot√≥n eliminar (si hay m√°s de un turno)
          if (turnos.length > 1) {
            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'turno-delete';
            deleteBtn.innerHTML = '<i class="fas fa-times"></i>';
            deleteBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              removeTurno(index);
            });
            turnoItem.appendChild(deleteBtn);
          }

          // C√≠rculo del turno
          const turnoCircle = document.createElement('div');
          turnoCircle.className = 'turno-circle turno-' + (turno === 'FS' ? 'fs' : turno.toLowerCase());
          turnoCircle.textContent = turno;
          turnoItem.appendChild(turnoCircle);

          // Etiqueta de horario o "Libre"
          if (turno !== 'FS') {
            const horarioLabel = document.createElement('div');
            horarioLabel.style.fontSize = '10px';
            horarioLabel.style.color = '#666';
            horarioLabel.textContent = `${config.horarios[turno].inicio}-${config.horarios[turno].fin}`;
            turnoItem.appendChild(horarioLabel);
          } else {
            const fsLabel = document.createElement('div');
            fsLabel.style.fontSize = '10px';
            fsLabel.style.color = '#666';
            fsLabel.textContent = 'Lliure';
            turnoItem.appendChild(fsLabel);
          }
          
          // A√±adir al contenedor
          elementos.turnoSequence.appendChild(turnoItem);

          // Flechas e indicadores de descanso entre turnos
          if (index < turnos.length - 1) {
            // Flecha de conexi√≥n
            const arrow = document.createElement('div');
            arrow.className = 'arrow';
            arrow.innerHTML = '<i class="fas fa-long-arrow-alt-right"></i>';
            elementos.turnoSequence.appendChild(arrow);

            // Calculamos descanso solo entre turnos de trabajo (no FS)
            if (turnos[index] !== 'FS' && turnos[index+1] !== 'FS') {
              // Crear indicador de descanso
              const descansoIndicator = document.createElement('div');
              descansoIndicator.className = 'descanso-indicator';
              
              // Mostrar horas de descanso
              const descansoHours = document.createElement('div');
              descansoHours.className = 'descanso-hours';
              const horasDescanso = calcularDescanso(turnos[index], turnos[index+1]);
              descansoHours.textContent = horasDescanso;
              descansoIndicator.appendChild(descansoHours);

              // Comprobar si hay d√©ficit
              const descansoMinutos = calcularDescansoEnMinutos(turnos[index], turnos[index+1]);
              if (descansoMinutos < config.descansoReglamentario) {
                // Mostrar d√©ficit
                const deficit = document.createElement('div');
                deficit.className = 'descanso-deficit';
                const deficitHoras = formatDuration((config.descansoReglamentario - descansoMinutos));
                
                // Comprobar si es cr√≠tico (menos del m√≠nimo legal)
                if (descansoMinutos < config.descansoMinimo) {
                  deficit.innerHTML = `<i class="fas fa-exclamation-triangle"></i> <strong>Incompleix descans</strong><br><strong>D√®ficit: ${deficitHoras}</strong>`;
                  deficit.style.borderColor = '#c62828';
                  deficit.style.background = 'linear-gradient(135deg, #ffcdd2 0%, #ef9a9a 100%)';
                } else {
                  deficit.innerHTML = `<strong>Incompleix descans</strong><br><strong>D√®ficit: ${deficitHoras}</strong>`;
                }
                
                descansoIndicator.appendChild(deficit);
              } else {
                // Cumple reglamentario
                const ok = document.createElement('div');
                ok.className = 'descanso-ok';
                ok.innerHTML = '<i class="fas fa-check-circle"></i> <strong>Compleix descans</strong>';
                
                // Verificar si este descanso est√° compensando alg√∫n d√©ficit anterior
                const exceso = descansoMinutos - config.descansoReglamentario;
                if (exceso > 0) {
                  // Buscar TODOS los d√©ficits que este descanso est√° ayudando a compensar
                  const deficitsQueCompensa = deficitsOriginales.filter(d => 
                    d.compensadoPor && 
                    d.compensadoPor.some(cp => cp.indice === index && !cp.incluyeFS)
                  );
                  
                  if (deficitsQueCompensa.length > 0) {
                    // Calcular totales
                    let totalCompensado = 0;
                    let totalDeficitOriginal = 0;
                    let hayCompensacionParcial = false;
                    
                    deficitsQueCompensa.forEach(deficit => {
                      const cantidadDeEsteDescanso = deficit.compensadoPor
                        .filter(cp => cp.indice === index)
                        .reduce((sum, cp) => sum + cp.cantidad, 0);
                      
                      totalCompensado += cantidadDeEsteDescanso;
                      totalDeficitOriginal += deficit.deficitOriginal;
                      
                      if (!deficit.compensado) {
                        hayCompensacionParcial = true;
                      }
                    });
                    
                    // Crear UN SOLO mensaje
                    const notaCompensacion = document.createElement('div');
                    notaCompensacion.style.fontSize = '10px';
                    notaCompensacion.style.marginTop = '4px';
                    notaCompensacion.style.fontWeight = '500';
                    notaCompensacion.style.padding = '4px 8px';
                    notaCompensacion.style.borderRadius = '4px';
                    
                    const numDeficits = deficitsQueCompensa.length;
                    const textoDeficits = numDeficits === 1 ? 'd√®ficit anterior' : `${numDeficits} d√®ficits anteriors`;
                    
                    if (hayCompensacionParcial) {
                      // COMPENSACI√ìN PARCIAL - NARANJA
                      const diferencia = totalDeficitOriginal - totalCompensado;
                      notaCompensacion.style.color = '#e65100';
                      notaCompensacion.style.backgroundColor = '#fff3e0';
                      notaCompensacion.style.borderLeft = '3px solid #ff9800';
                      notaCompensacion.innerHTML = `<i class="fas fa-exclamation-circle"></i> Compensa parcialment ${textoDeficits} (${formatDuration(totalCompensado)} de ${formatDuration(totalDeficitOriginal)}, queden ${formatDuration(diferencia)})`;
                    } else {
                      // COMPENSACI√ìN TOTAL - AZUL
                      notaCompensacion.style.color = '#1976d2';
                      notaCompensacion.style.backgroundColor = '#e3f2fd';
                      notaCompensacion.style.borderLeft = '3px solid #1976d2';
                      notaCompensacion.innerHTML = `<i class="fas fa-check-circle"></i> Compensa ${textoDeficits} (${formatDuration(totalCompensado)})`;
                    }
                    
                    ok.appendChild(notaCompensacion);
                  }
                }
                
                descansoIndicator.appendChild(ok);
              }
              
              // A√±adir al contenedor
              elementos.turnoSequence.appendChild(descansoIndicator);

              // Segunda flecha
              const arrow2 = document.createElement('div');
              arrow2.className = 'arrow';
              arrow2.innerHTML = '<i class="fas fa-long-arrow-alt-right"></i>';
              elementos.turnoSequence.appendChild(arrow2);
            }
          }
        });

        // Bot√≥n extra para a√±adir turno
        const addTurnoBtn = document.createElement('div');
        addTurnoBtn.className = 'turno-item';
        const addTurnoCircle = document.createElement('div');
        addTurnoCircle.className = 'turno-circle';
        addTurnoCircle.style.backgroundColor = '#ddd';
        addTurnoCircle.style.color = '#333';
        addTurnoCircle.textContent = '+';
        addTurnoCircle.style.fontSize = '24px';
        addTurnoCircle.style.cursor = 'pointer';
        addTurnoCircle.addEventListener('click', showModal);
        addTurnoBtn.appendChild(addTurnoCircle);

        const addLabel = document.createElement('div');
        addLabel.style.fontSize = '10px';
        addLabel.style.color = '#666';
        addLabel.textContent = 'Afegir';
        addTurnoBtn.appendChild(addLabel);

        elementos.turnoSequence.appendChild(addTurnoBtn);
      } catch (error) {
        console.error("Error al renderizar turnos:", error);
        mostrarMensaje("Error en mostrar la seq√º√®ncia de torns", "error");
        
        // Intentar limpiar la vista en caso de error
        try {
          elementos.turnoSequence.innerHTML = '<div style="color: red;">Error en mostrar torns. Si us plau, recarrega la p√†gina.</div>';
        } catch (e) {
          console.error("Error cr√≠tico al recuperar de error:", e);
        }
      }
    }

    /* ======== DETECTAR Y COMPENSAR D√âFICITS ======== */
    /**
     * Calcula el d√©ficit con posible compensaci√≥n en una secuencia de turnos
 * @param {array} schedule - Secuencia de turnos a analizar
 * @returns {object} Resultado con d√©ficits y d√©ficit neto
 */
function calcularDeficitConCompensacion(schedule) {
  try {
    // Validar entrada
    if (!schedule || !Array.isArray(schedule) || schedule.length < 2) {
      return { deficits: [], netDeficit: 0 };
    }
    
    // 1. Recoger d√©ficits y excesos de descanso
    const deficits = [];
    const excesos = [];
    
    for (let i = 0; i < schedule.length - 1; i++) {
      // Saltar si alguno es d√≠a libre
      if (schedule[i] === 'FS' || schedule[i+1] === 'FS') continue;
      
      // Calcular descanso entre turnos
      const descanso = calcularDescansoEnMinutos(schedule[i], schedule[i+1]);
      
      // Registrar d√©ficit si existe
      if (descanso < config.descansoReglamentario) {
        const deficitOriginal = config.descansoReglamentario - descanso;
        deficits.push({
          indice: i,
          turnoActual: schedule[i],
          turnoSiguiente: schedule[i+1],
          descansoActual: descanso,
          deficit: deficitOriginal,
          deficitOriginal: deficitOriginal, // GUARDAR SIEMPRE EL D√âFICIT ORIGINAL
          compensado: false
        });
      } 
      // Registrar exceso si existe (para posibles compensaciones)
      else if (descanso > config.descansoReglamentario) {
        excesos.push({
          indice: i,
          exceso: descanso - config.descansoReglamentario
        });
      }
    }

    // GUARDAR UNA COPIA DE LOS D√âFICITS ORIGINALES ANTES DE COMPENSAR
    // Esta copia se actualiza al final con informaci√≥n de compensaci√≥n
    const deficitsOriginalesSinModificar = deficits.map(d => ({...d, compensadoPor: []}));
    
    // 2. Usar los excesos para compensar d√©ficits previos
    for (let d = 0; d < deficits.length; d++) {
      const def = deficits[d];
      
      // Buscar excesos posteriores que puedan compensar este d√©ficit
      for (let e = 0; e < excesos.length; e++) {
        const exc = excesos[e];
        
        // Solo usar excesos que ocurren despu√©s del d√©ficit
        if (exc.indice > def.indice) {
          // Calcular cu√°nto del exceso podemos usar para la compensaci√≥n
          const compensacionPosible = Math.min(def.deficit, exc.exceso);
          
          if (compensacionPosible > 0) {
            // Aplicar compensaci√≥n
            def.deficit -= compensacionPosible;
            def.compensacionAplicada = (def.compensacionAplicada || 0) + compensacionPosible;
            
            // Registrar qu√© √≠ndices est√°n compensando este d√©ficit
            if (!def.compensadoPor) {
              def.compensadoPor = [];
            }
            def.compensadoPor.push({
              indice: exc.indice,
              cantidad: compensacionPosible
            });
            
            // Reducir el exceso disponible
            exc.exceso -= compensacionPosible;
            
            // Si el d√©ficit qued√≥ completamente compensado, marcar y salir
            if (def.deficit <= 0) {
              def.deficit = 0;
              def.compensado = true;
              break;
            }
          }
        }
      }
    }

    // 3. Para los d√©ficits que a√∫n no est√©n compensados, intentar con per√≠odos que incluyan FS
    for (let d = 0; d < deficits.length; d++) {
      const def = deficits[d];
      
      // Si ya est√° compensado, saltar
      if (def.compensado) continue;
      
      const idx = def.indice;
      
      // Buscar per√≠odos de descanso extendidos con FS
      for (let j = idx + 1; j < schedule.length - 1; j++) {
        if (schedule[j] === 'FS' && j + 1 < schedule.length) {
          // Calcular descanso extendido desde el final del turno con d√©ficit 
          // hasta el inicio del turno despu√©s del FS
          const inicioSiguiente = j + 1 < schedule.length ? schedule[j+1] : null;
          
          if (inicioSiguiente) {
            // Calcular el tiempo total desde el fin del turno deficitario hasta el inicio del turno post-FS
            const finTurnoDeficit = config.horarios[schedule[idx]].fin;
            const inicioTurnoPostFS = config.horarios[inicioSiguiente].inicio;
            
            // Calcular minutos totales (considerando si cruza medianoche)
            let minutosFin = convertToMinutes(finTurnoDeficit);
            let minutosInicio = convertToMinutes(inicioTurnoPostFS);
            
            // Si el inicio es antes que el fin, a√±adir d√≠as completos seg√∫n la posici√≥n
            const diasEntre = j - idx;
            let minutosDescanso = 0;
            
            if (minutosInicio < minutosFin) {
              minutosDescanso = minutosInicio + (config.minutosDia * diasEntre) - minutosFin;
            } else {
              minutosDescanso = minutosInicio + (config.minutosDia * (diasEntre - 1)) - minutosFin;
            }
            
            // Calcular exceso sobre el reglamentario
            const exceso = minutosDescanso - config.descansoReglamentario;
            
            if (exceso > 0) {
              // Aplicar compensaci√≥n
              const compensacion = Math.min(def.deficit, exceso);
              def.deficit -= compensacion;
              def.compensacionAplicada = (def.compensacionAplicada || 0) + compensacion;
              
              // Registrar que esta compensaci√≥n viene de un per√≠odo con FS
              if (!def.compensadoPor) {
                def.compensadoPor = [];
              }
              def.compensadoPor.push({
                indice: j, // √≠ndice donde est√° el FS
                cantidad: compensacion,
                incluyeFS: true
              });
              
              if (def.deficit <= 0) {
                def.deficit = 0;
                def.compensado = true;
                break;
              }
            }
          }
        }
      }
    }

    // Actualizar la copia de d√©ficits originales con informaci√≥n de compensaci√≥n
    for (let i = 0; i < deficits.length; i++) {
      // Copiar informaci√≥n de compensaci√≥n tanto si est√° totalmente compensado como parcialmente
      if (deficits[i].compensadoPor && deficits[i].compensadoPor.length > 0) {
        deficitsOriginalesSinModificar[i].compensadoPor = deficits[i].compensadoPor;
        deficitsOriginalesSinModificar[i].compensacionAplicada = deficits[i].compensacionAplicada;
        deficitsOriginalesSinModificar[i].compensado = deficits[i].compensado; // true si total, false si parcial
      }
    }
    
    // Calcular d√©ficit neto total (solo de los no compensados)
    const deficitsFiltrados = deficits.filter(d => d.deficit > 0);
    const netDeficit = deficitsFiltrados.reduce((sum, d) => sum + d.deficit, 0);
    
    return { 
      deficits: deficitsFiltrados, 
      deficitsOriginales: deficitsOriginalesSinModificar, // Usar la copia actualizada con info de compensaci√≥n
      netDeficit 
    };
  } catch (error) {
    console.error("Error al calcular d√©ficit con compensaci√≥n:", error);
    return { deficits: [], netDeficit: 0, error: true };
  }
}

    /* ======== AN√ÅLISIS GENERAL DE LA SECUENCIA ======== */
    /**
     * Analiza la secuencia completa de turnos y actualiza la UI
     */
    function analyzeSequence() {
      try {
        // Si no hay suficientes turnos, no hacer nada
        if (turnos.length < 2) {
          hideResults();
          return;
        }
        
        // Usar an√°lisis en cach√© si existe y la secuencia no ha cambiado
        if (ultimoAnalisis && ultimoAnalisis.turnos.length === turnos.length && 
            JSON.stringify(ultimoAnalisis.turnos) === JSON.stringify(turnos)) {
          updateResults(ultimoAnalisis.deficits, ultimoAnalisis.netDeficit);
          
          // Mostrar u ocultar recomendaciones seg√∫n haya d√©ficit
          if (ultimoAnalisis.netDeficit > 0) {
            elementos.resultsSection.style.display = 'block';
            elementos.recommendationsSection.style.display = 'block';
            updateRecommendations(turnos[turnos.length - 1], ultimoAnalisis.netDeficit);
            elementos.calendarSection.style.display = 'block';
          } else {
            elementos.resultsSection.style.display = 'block';
            elementos.recommendationsSection.style.display = 'none';
            elementos.calendarSection.style.display = 'block';
            elementos.calendarView.innerHTML = '<div style="color: var(--color-success); font-weight: bold;">No cal compensaci√≥.</div>';
          }
          
          return;
        }
        
        // Realizar un nuevo an√°lisis
        const resultado = calcularDeficitConCompensacion(turnos);
        
        // Guardar resultados para uso futuro
        deficitsDetallados = resultado.deficits;
        currentDeficitMinutes = resultado.netDeficit;
        
        // Guardar an√°lisis completo en cach√©
        ultimoAnalisis = {
          turnos: [...turnos],
          deficits: resultado.deficits,
          deficitsOriginales: resultado.deficitsOriginales,
          netDeficit: resultado.netDeficit
        };
        
        // Actualizar UI
        updateResults(resultado.deficits, resultado.netDeficit);

        // Mostrar u ocultar recomendaciones
        if (resultado.netDeficit > 0) {
          elementos.resultsSection.style.display = 'block';
          elementos.recommendationsSection.style.display = 'block';
          updateRecommendations(turnos[turnos.length - 1], resultado.netDeficit);
          elementos.calendarSection.style.display = 'block';
        } else {
          elementos.resultsSection.style.display = 'block';
          elementos.recommendationsSection.style.display = 'none';
          elementos.calendarSection.style.display = 'block';
          elementos.calendarView.innerHTML = '<div style="color: var(--color-success); font-weight: bold; padding: 10px;">No cal compensaci√≥.</div>';
        }
      } catch (error) {
        console.error("Error al analizar secuencia:", error);
        mostrarMensaje("Error en analitzar la seq√º√®ncia de torns", "error");
        
        // Intentar mostrar resultados parciales o un mensaje de error
        elementos.resultsSection.style.display = 'none';
        elementos.recommendationsSection.style.display = 'none';
        elementos.calendarSection.style.display = 'none';
      }
    }

    /**
     * Detecta patrones en los d√©ficits
     * @param {array} deficits - Lista de d√©ficits detectados
     * @returns {object} Tipo y descripci√≥n del patr√≥n
     */
    function detectPattern(deficits) {
      try {
        // Si no hay d√©ficits, devolver "sin d√©ficit"
        const numDeficits = deficits.length;
        if (numDeficits === 0) {
          return { 
            type: 'none', 
            description: 'Sense d√®ficit',
            icon: 'fa-check-circle',
            color: 'var(--color-success)'
          };
        }
        
        // D√©ficit simple (un solo d√©ficit)
        if (numDeficits === 1) {
          return {
            type: 'simple',
            description: 'D√®ficit Simple',
            details: `Existeix una √∫nica transici√≥ amb descans inferior al reglamentari de 12h.`,
            icon: 'fa-info-circle',
            color: 'var(--color-morning)'
          };
        }
        
        // Buscar d√©ficits consecutivos
        let maxConsecutivos = 1, consecutivosActuales = 1;
        
        for (let i = 1; i < deficits.length; i++) {
          if (deficits[i-1].indice + 1 === deficits[i].indice) {
            consecutivosActuales++;
          } else {
            consecutivosActuales = 1;
          }
          maxConsecutivos = Math.max(maxConsecutivos, consecutivosActuales);
        }
        
        // Triple d√©ficit o m√°s
        if (maxConsecutivos >= 3) {
          return {
            type: 'triple',
            description: 'Triple D√®ficit',
            details: `S'acumulen ${maxConsecutivos} transicions consecutives deficit√†ries.`,
            icon: 'fa-radiation',
            color: 'var(--color-double)'
          };
        }
        
        // Doble d√©ficit
        if (maxConsecutivos === 2) {
          return {
            type: 'double',
            description: 'D√®ficit Doble',
            details: `Existeix un doble d√®ficit consecutiu que incrementa la fatiga acumulada.`,
            icon: 'fa-exclamation-triangle',
            color: 'var(--color-afternoon)'
          };
        }
        
        // D√©ficits alternados (no consecutivos)
        return {
          type: 'alternated',
          description: 'D√®ficits Alternats',
          details: `Existeixen ${numDeficits} d√®ficits separats per transicions que s√≠ compleixen amb el descans reglamentari.`,
          icon: 'fa-exchange-alt',
          color: 'var(--color-success)'
        };
      } catch (error) {
        console.error("Error al detectar patr√≥n:", error);
        return { 
          type: 'error', 
          description: 'Error en analitzar', 
          details: 'No s\'ha pogut determinar el patr√≥ espec√≠fic.',
          icon: 'fa-exclamation-circle',
          color: 'var(--color-warning)'
        };
      }
    }

    /**
     * Actualiza la interfaz de resultados
     * @param {array} deficits - Lista de d√©ficits detectados
     * @param {number} netDeficit - D√©ficit neto total en minutos
     */
    function updateResults(deficits, netDeficit) {
      try {
        const pattern = detectPattern(deficits);
        updatePatternUI(pattern, netDeficit, deficits.length);
      } catch (error) {
        console.error("Error al actualizar resultados:", error);
        mostrarMensaje("Error en mostrar resultats", "error");
      }
    }
  </script>
  <script>
    /* ======== MOSTRAR PATR√ìN Y COMPENSACI√ìN ======== */
    /**
     * Actualiza la interfaz con la informaci√≥n del patr√≥n detectado
     * @param {object} pattern - Patr√≥n detectado
     * @param {number} netDeficit - D√©ficit neto total en minutos
     * @param {number} numDeficits - N√∫mero de d√©ficits
     */
    function updatePatternUI(pattern, netDeficit, numDeficits) {
      try {
        // Obtener referencias
        const patternBox = elementos.patternBox;
        const patternTitle = patternBox.querySelector('.pattern-title');
        const patternNameSpan = elementos.patternName;
        const patternDescription = elementos.patternDescription;

        // Resetear clases
        patternBox.className = 'pattern-box';
        
        // Actualizar seg√∫n patr√≥n
        switch(pattern.type) {
          case 'none':
            patternBox.classList.add('pattern-simple');
            patternTitle.innerHTML = `<i class="fas ${pattern.icon}"></i> <strong>Sense d√®ficits</strong>`;
            patternNameSpan.textContent = 'Sense d√®ficits';
            patternDescription.textContent = `Totes les transicions compleixen el descans m√≠nim reglamentari de ${formatDuration(config.descansoReglamentario)} hores.`;
            break;
          case 'simple':
            patternBox.classList.add('pattern-simple');
            patternTitle.innerHTML = `<i class="fas ${pattern.icon}"></i> <strong>Patr√≥ detectat:</strong> <span id="pattern-name">${pattern.description}</span>`;
            patternNameSpan.textContent = pattern.description;
            patternDescription.innerHTML = `${pattern.details}<br>D√®ficit net: ${formatDuration(netDeficit)} hores.`;
            break;
          case 'double':
            patternBox.classList.add('pattern-double');
            patternTitle.innerHTML = `<i class="fas ${pattern.icon}"></i> <strong>Patr√≥ Detectat:</strong> <span id="pattern-name">${pattern.description}</span>`;
            patternNameSpan.textContent = pattern.description;
            patternDescription.innerHTML = `${pattern.details}<br>D√®ficit net: ${formatDuration(netDeficit)} hores.`;
            break;
          case 'triple':
            patternBox.classList.add('pattern-triple');
            patternTitle.innerHTML = `<i class="fas ${pattern.icon}"></i> <strong>Patr√≥ Detectat:</strong> <span id="pattern-name">${pattern.description}</span>`;
            patternNameSpan.textContent = pattern.description;
            patternDescription.innerHTML = `${pattern.details}<br>D√®ficit net: ${formatDuration(netDeficit)} hores.`;
            break;
          case 'alternated':
            patternBox.classList.add('pattern-alternated');
            patternTitle.innerHTML = `<i class="fas ${pattern.icon}"></i> <strong>Patr√≥ Detectat:</strong> <span id="pattern-name">${pattern.description}</span>`;
            patternNameSpan.textContent = pattern.description;
            patternDescription.innerHTML = `${pattern.details}<br>D√®ficit net total: ${formatDuration(netDeficit)} hores en ${numDeficits} transicions.`;
            break;
          default:
            patternBox.classList.add('pattern-double');
            patternTitle.innerHTML = `<i class="fas fa-exclamation-circle"></i> <strong>An√†lisi:</strong>`;
            patternNameSpan.textContent = "An√†lisi de d√®ficit";
            patternDescription.innerHTML = `S'ha detectat un d√®ficit total de ${formatDuration(netDeficit)} hores.`;
        }
        
        // Actualizar n√∫meros de resumen
        const deficitTotalElement = elementos.deficitTotal;
        const compensacionElement = elementos.compensacionRequerida;
        const transicionesElement = elementos.transicionesDeficitarias;
        
        // Calcular la compensaci√≥n necesaria (d√©ficit + descanso reglamentario para el siguiente turno)
        const finalCompensacion = netDeficit > 0 ? netDeficit : 0;

        // Actualizar elementos de la interfaz y aplicar estilos rojos si hay d√©ficit
        const deficitBoxes = document.querySelectorAll('.deficit-box');
        
        if (netDeficit === 0) {
          deficitTotalElement.textContent = '0:00';
          deficitTotalElement.style.color = 'var(--color-success)';
          compensacionElement.textContent = '0:00';
          compensacionElement.style.color = 'var(--color-success)';
          
          // Quitar la clase de d√©ficit de todas las cajas
          deficitBoxes.forEach(box => box.classList.remove('has-deficit'));
        } else {
          deficitTotalElement.textContent = formatDuration(netDeficit);
          compensacionElement.textContent = formatDuration(finalCompensacion);
          
          // A√±adir la clase de d√©ficit a todas las cajas
          deficitBoxes.forEach(box => box.classList.add('has-deficit'));
        }
        
        transicionesElement.textContent = numDeficits;
      } catch (error) {
        console.error("Error al actualizar interfaz de patr√≥n:", error);
        
        // Intentar mostrar un mensaje b√°sico en caso de error
        try {
          elementos.patternBox.innerHTML = `<div style="color: var(--color-warning);">Error en mostrar el patr√≥. D√®ficit total: ${formatDuration(netDeficit)}</div>`;
        } catch (e) {
          console.error("Error cr√≠tico al recuperar de error:", e);
        }
      }
    }

    /* ======== RECOMENDACIONES ======== */
    /**
     * Actualiza las recomendaciones basadas en el √∫ltimo turno y d√©ficit
     * @param {string} lastTurno - √öltimo turno de la secuencia
     * @param {number} deficitMinutes - D√©ficit total en minutos
     */
     function updateRecommendations(lastTurno, deficitMinutes) {
  try {
    const optionsContainer = elementos.compensationOptions;
    const recText = elementos.recommendationText;
    
    // Limpiar contenedor
    optionsContainer.innerHTML = '';
    
    // Si no hay d√©ficit, no mostrar opciones
    if (deficitMinutes === 0) {
      recText.innerHTML = "No es requereixen compensacions ja que no hi ha d√®ficit de descans.";
      return;
    }
    
    // Texto de recomendaci√≥n
    recText.innerHTML = `<p>S'ha detectat un d√®ficit de descans de <strong>${formatDuration(deficitMinutes)}</strong> hores. 
                       A continuaci√≥ es presenten opcions per compensar aquest d√®ficit mitjan√ßant la programaci√≥
                       dels seg√ºents torns.</p>`;
    
    // Generar opciones seg√∫n el √∫ltimo turno
    let options = [];
    
    // C√°lculo b√°sico para turnos simples
    const recupManiana = calcularDescansoEnMinutos(lastTurno, 'M') - config.descansoReglamentario;
    const recupTarde = calcularDescansoEnMinutos(lastTurno, 'T') - config.descansoReglamentario;
    
    // C√°lculo mejorado para turnos con FS (d√≠a libre)
    // Esto calcula el tiempo real desde el fin del √∫ltimo turno hasta el inicio del siguiente
    const finUltimoTurno = convertToMinutes(config.horarios[lastTurno].fin);
    const inicioTurnoM = convertToMinutes(config.horarios['M'].inicio);
    const inicioTurnoT = convertToMinutes(config.horarios['T'].inicio);
    
    // Calcular tiempo total incluyendo un d√≠a completo en medio
    let recupFSM;
    if (inicioTurnoM > finUltimoTurno) {
      // Sin cruce de medianoche
      recupFSM = (config.minutosDia + inicioTurnoM - finUltimoTurno) - config.descansoReglamentario;
    } else {
      // Con cruce de medianoche
      recupFSM = (2 * config.minutosDia + inicioTurnoM - finUltimoTurno) - config.descansoReglamentario;
    }
    
    let recupFST;
    if (inicioTurnoT > finUltimoTurno) {
      // Sin cruce de medianoche
      recupFST = (config.minutosDia + inicioTurnoT - finUltimoTurno) - config.descansoReglamentario;
    } else {
      // Con cruce de medianoche
      recupFST = (2 * config.minutosDia + inicioTurnoT - finUltimoTurno) - config.descansoReglamentario;
    }
    
    // Agregar opci√≥n de Ma√±ana si proporciona recuperaci√≥n positiva
    if (recupManiana > 0) {
      options.push({ 
        title: "Mat√≠", 
        turns: ["M"], 
        recovery: formatDuration(recupManiana), 
        recoveryMinutes: recupManiana,
        description: "Torn Mat√≠ per recuperar descans.",
        adecuado: recupManiana >= deficitMinutes
      });
    }
    
    // Agregar opci√≥n de Tarde si proporciona recuperaci√≥n positiva
    if (recupTarde > 0) {
      options.push({ 
        title: "Tarda", 
        turns: ["T"], 
        recovery: formatDuration(recupTarde),
        recoveryMinutes: recupTarde,
        description: "Torn Tarda per recuperar descans.",
        adecuado: recupTarde >= deficitMinutes
      });
    }
    
    // Agregar opciones con d√≠a libre
    options.push({ 
      title: "FS + M", 
      turns: ["FS", "M"], 
      recovery: formatDuration(recupFSM),
      recoveryMinutes: recupFSM,
      description: "Dia lliure + Mat√≠.",
      adecuado: recupFSM >= deficitMinutes
    });
    
    options.push({ 
      title: "FS + T", 
      turns: ["FS", "T"], 
      recovery: formatDuration(recupFST),
      recoveryMinutes: recupFST,
      description: "Dia lliure + Tarda.",
      adecuado: recupFST >= deficitMinutes
    });
    
    // Filtrar opciones que no proporcionan recuperaci√≥n
    options = options.filter(opt => opt.recoveryMinutes > 0);
    
    // Ordenar opciones por tiempo de recuperaci√≥n (de menos a m√°s)
    options.sort((a, b) => a.recoveryMinutes - b.recoveryMinutes);
    
    // Crear opciones en la interfaz
    options.forEach((opt, idx) => {
      addCompensationOption(opt, idx === 0);
    });
    
    // Actualizar calendario con la opci√≥n seleccionada
    updateAdaptedSchedule();
  } catch (error) {
    console.error("Error al actualizar recomendaciones:", error);
    try {
      elementos.recommendationText.innerHTML = '<div style="color: var(--color-warning);">No s\'han pogut generar recomanacions. Si us plau, torna-ho a intentar.</div>';
      elementos.compensationOptions.innerHTML = '';
    } catch (e) {
      console.error("Error cr√≠tico al recuperar de error:", e);
    }
  }
}

    /**
     * A√±ade una opci√≥n de compensaci√≥n a la interfaz
     * @param {object} option - Datos de la opci√≥n
     * @param {boolean} selected - Si est√° seleccionada inicialmente
     */
    function addCompensationOption(option, selected = false) {
      try {
        const optionsContainer = elementos.compensationOptions;
        
        // Crear elemento de opci√≥n
        const optionElement = document.createElement('div');
        optionElement.className = 'compensation-option' + (selected ? ' selected' : '');
        optionElement.dataset.turns = JSON.stringify(option.turns);
        optionElement.dataset.recovery = option.recovery;
        optionElement.dataset.adecuado = option.adecuado;

        // T√≠tulo con iconos de turnos
        const optionTitle = document.createElement('div');
        optionTitle.className = 'option-title';
        let titleHtml = '';
        
        // A√±adir c√≠rculos de turnos
        option.turns.forEach(turn => {
          const turnoClass = turn === 'FS' ? 'turno-fs' : 'turno-' + turn.toLowerCase();
          titleHtml += `<span class="turno-circle ${turnoClass}" style="width: 25px; height: 25px; font-size: 12px;">${turn}</span> `;
        });
        
        titleHtml += option.title;
        optionTitle.innerHTML = titleHtml;
        
        // A√±adir icono de seleccionado si es el caso
        if (selected) {
          const icon = document.createElement('i');
          icon.className = 'fas fa-check-circle';
          icon.style.color = 'var(--color-success)';
          optionTitle.appendChild(icon);
        }
        
        // Descripci√≥n y recuperaci√≥n
        const optionDesc = document.createElement('div');
        optionDesc.className = 'option-description';
        
        // Indicar si la recuperaci√≥n es adecuada
        const adecuadoText = option.adecuado 
          ? `<span style="color: var(--color-success);"><i class="fas fa-check-circle"></i> Suficient per compensar el d√®ficit</span>` 
          : `<span style="color: var(--color-warning);"><i class="fas fa-exclamation-circle"></i> No compensa totalment el d√®ficit</span>`;
          
        optionDesc.innerHTML = `${option.description}<br><strong>Recuperaci√≥: ${option.recovery}h</strong><br>${adecuadoText}`;
        
        // A√±adir elementos al contenedor
        optionElement.appendChild(optionTitle);
        optionElement.appendChild(optionDesc);

        // A√±adir evento de clic
        optionElement.addEventListener('click', function() {
          // Desmarcar todas las opciones
          document.querySelectorAll('.compensation-option').forEach(o => {
            o.classList.remove('selected');
            const checkIcon = o.querySelector('.fa-check-circle');
            if (checkIcon) checkIcon.remove();
          });
          
          // Marcar esta opci√≥n
          this.classList.add('selected');
          
          // A√±adir icono de seleccionado
          const icon = document.createElement('i');
          icon.className = 'fas fa-check-circle';
          icon.style.color = 'var(--color-success)';
          this.querySelector('.option-title').appendChild(icon);
          
          // Actualizar calendario
          updateAdaptedSchedule();
        });
        
        // A√±adir al contenedor principal
        optionsContainer.appendChild(optionElement);
      } catch (error) {
        console.error("Error al a√±adir opci√≥n de compensaci√≥n:", error);
      }
    }

    /* ======== HORARIO ADAPTADO ======== */
    /**
     * Actualiza el horario adaptado con la opci√≥n seleccionada
     */
    function updateAdaptedSchedule() {
      try {
        const selectedOption = document.querySelector('.compensation-option.selected');
        if (!selectedOption) {
          elementos.calendarView.innerHTML = '<div style="color: var(--color-text-light); padding: 10px;">Selecciona una opci√≥ de compensaci√≥ per veure l\'horari adaptat.</div>';
          return;
        }
        
        // Obtener datos de la opci√≥n seleccionada
        const turnsData = selectedOption.dataset.turns;
        const recovery = selectedOption.dataset.recovery;
        const esAdecuado = selectedOption.dataset.adecuado === 'true';
        
        // Validar datos
        if (!turnsData) {
          throw new Error('No se encontraron datos de turnos en la opci√≥n seleccionada');
        }
        
        // Parsear turnos recomendados
        const turnsRecomendados = JSON.parse(turnsData);
        if (!Array.isArray(turnsRecomendados)) {
          throw new Error('Los datos de turnos no son un array v√°lido');
        }
        
        // Crear nuevo horario con los turnos originales y recomendados
        const newSchedule = [...turnos, ...turnsRecomendados];
        
        // Renderizar el horario adaptado
        renderAdaptedSchedule(newSchedule, turnos.length, recovery, esAdecuado);
      } catch (error) {
        console.error('Error al actualizar horario adaptado:', error);
        mostrarMensaje('Error en generar horari adaptat', 'error');
        
        // Mostrar mensaje de error en la secci√≥n
        elementos.calendarView.innerHTML = `
          <div style="color: var(--color-warning); padding: 10px;">
            <i class="fas fa-exclamation-triangle"></i> 
            No s'ha pogut generar l'horari adaptat. Si us plau, torna-ho a intentar.
          </div>`;
      }
    }

    /**
     * Renderiza el horario adaptado con compensaci√≥n
     * @param {array} schedule - Secuencia completa de turnos
     * @param {number} originalCount - Cantidad de turnos originales
     * @param {string} recoveryTime - Tiempo de recuperaci√≥n (formato HH:MM)
     * @param {boolean} esAdecuado - Si la compensaci√≥n es adecuada
     */
    function renderAdaptedSchedule(schedule, originalCount, recoveryTime, esAdecuado) {
      try {
        // Limpiar contenedor
        elementos.calendarView.innerHTML = '';
        
        // Validar datos
        if (!Array.isArray(schedule) || schedule.length === 0) {
          const errorMsg = document.createElement('div');
          errorMsg.textContent = 'No hi ha suficients dades per mostrar l\'horari adaptat.';
          errorMsg.style.color = 'var(--color-warning)';
          elementos.calendarView.appendChild(errorMsg);
          return;
        }

        // Detectar d√©ficits en este nuevo schedule
        const { deficits, netDeficit } = calcularDeficitConCompensacion(schedule);
        
        // Mensaje de estado de compensaci√≥n
        const estadoCompensacion = document.createElement('div');
        estadoCompensacion.style.marginBottom = '15px';
        estadoCompensacion.style.padding = '10px';
        estadoCompensacion.style.borderRadius = 'var(--radius)';
        
        if (netDeficit === 0) {
          estadoCompensacion.style.backgroundColor = '#e8f5e9';
          estadoCompensacion.style.color = 'var(--color-success)';
          estadoCompensacion.style.borderLeft = '4px solid var(--color-success)';
          estadoCompensacion.innerHTML = `
            <i class="fas fa-check-circle"></i> 
            <strong>Compensaci√≥ completa:</strong> Amb aquesta opci√≥ es recupera tot el d√®ficit de descans.
          `;
        } else if (esAdecuado) {
          estadoCompensacion.style.backgroundColor = '#fff8e1';
          estadoCompensacion.style.color = '#ff9800';
          estadoCompensacion.style.borderLeft = '4px solid #ff9800';
          estadoCompensacion.innerHTML = `
            <i class="fas fa-info-circle"></i> 
            <strong>Compensaci√≥ te√≤rica:</strong> El temps recuperat √©s suficient, per√≤ encara queda un d√®ficit t√®cnic de ${formatDuration(netDeficit)}.
          `;
        } else {
          estadoCompensacion.style.backgroundColor = '#ffebee';
          estadoCompensacion.style.color = 'var(--color-warning)';
          estadoCompensacion.style.borderLeft = '4px solid var(--color-warning)';
          estadoCompensacion.innerHTML = `
            <i class="fas fa-exclamation-circle"></i> 
            <strong>Compensaci√≥ parcial:</strong> Aquesta opci√≥ no recupera tot el d√®ficit. Queden ${formatDuration(netDeficit)} per compensar.
          `;
        }
        
        elementos.calendarView.appendChild(estadoCompensacion);

        // Contenedor para la secuencia
        const secuenciaContainer = document.createElement('div');
        secuenciaContainer.style.display = 'flex';
        secuenciaContainer.style.flexWrap = 'wrap';
        secuenciaContainer.style.gap = '10px';
        secuenciaContainer.style.alignItems = 'center';
        secuenciaContainer.style.backgroundColor = 'var(--color-background-alt)';
        secuenciaContainer.style.borderRadius = 'var(--radius)';
        secuenciaContainer.style.padding = '15px';
        
        // Indicador de separaci√≥n mostrado
        let separadorMostrado = false;
        
        // Dibujamos la secuencia adaptada
        schedule.forEach((turno, index) => {
          // A√±adir separador entre secuencia original y recomendaci√≥n
          if (index === originalCount && !separadorMostrado) {
            const sep = document.createElement('div');
            sep.className = 'sugerido-arrow';
            sep.innerHTML = `<i class="fas fa-arrow-right"></i>
                            <span>Compensaci√≥ seleccionada</span>
                            <span>(Recupera ${recoveryTime}h)</span>`;
            secuenciaContainer.appendChild(sep);
            separadorMostrado = true;
          }

          // Crear elemento de turno
          const turnoItem = document.createElement('div');
          turnoItem.className = 'turno-item';
          
          // A√±adir clase y estilos para turnos sugeridos
          if (index >= originalCount) {
            turnoItem.classList.add('sugerido');
            turnoItem.style.transform = 'scale(1.1)';
            turnoItem.style.position = 'relative';
            
            // Indicador de recomendado
            const recomendadoIndicator = document.createElement('div');
            recomendadoIndicator.style.position = 'absolute';
            recomendadoIndicator.style.top = '-10px';
            recomendadoIndicator.style.right = '-5px';
            recomendadoIndicator.style.background = 'var(--border-sugerido)';
            recomendadoIndicator.style.color = '#333';
            recomendadoIndicator.style.borderRadius = '50%';
            recomendadoIndicator.style.width = '18px';
            recomendadoIndicator.style.height = '18px';
            recomendadoIndicator.style.display = 'flex';
            recomendadoIndicator.style.alignItems = 'center';
            recomendadoIndicator.style.justifyContent = 'center';
            recomendadoIndicator.style.fontSize = '10px';
            recomendadoIndicator.style.zIndex = '5';
            recomendadoIndicator.innerHTML = '<i class="fas fa-check"></i>';
            turnoItem.appendChild(recomendadoIndicator);
          }

          // C√≠rculo del turno
          const turnoCircle = document.createElement('div');
          turnoCircle.className = 'turno-circle turno-' + (turno === 'FS' ? 'fs' : turno.toLowerCase());
          turnoCircle.textContent = turno;
          turnoItem.appendChild(turnoCircle);

          // Etiqueta de horario o "Libre"
          if (turno !== 'FS') {
            const horarioLabel = document.createElement('div');
            horarioLabel.style.fontSize = '10px';
            horarioLabel.style.color = '#666';
            horarioLabel.textContent = `${config.horarios[turno].inicio}-${config.horarios[turno].fin}`;
            turnoItem.appendChild(horarioLabel);
          } else {
            const fsLabel = document.createElement('div');
            fsLabel.style.fontSize = '10px';
            fsLabel.style.color = '#666';
            fsLabel.textContent = 'Lliure';
            turnoItem.appendChild(fsLabel);
          }
          
          // A√±adir a la secuencia
          secuenciaContainer.appendChild(turnoItem);

          // A√±adir flechas e indicadores entre turnos
          if (index < schedule.length - 1) {
            // Flecha
            const arrow = document.createElement('div');
            arrow.className = 'arrow';
            arrow.innerHTML = '<i class="fas fa-long-arrow-alt-right"></i>';
            secuenciaContainer.appendChild(arrow);

            // Indicador de descanso (solo entre turnos de trabajo)
            if (schedule[index] !== 'FS' && schedule[index+1] !== 'FS') {
              // Crear indicador
              const descansoIndicator = document.createElement('div');
              descansoIndicator.className = 'descanso-indicator';
              
              // Mostrar horas de descanso
              const descansoHours = document.createElement('div');
              descansoHours.className = 'descanso-hours';
              const horasDescanso = calcularDescanso(schedule[index], schedule[index+1]);
              descansoHours.textContent = horasDescanso;
              descansoIndicator.appendChild(descansoHours);

              // Comprobar d√©ficit
              const descansoMinutos = calcularDescansoEnMinutos(schedule[index], schedule[index+1]);
              if (descansoMinutos < config.descansoReglamentario) {
                // Mostrar d√©ficit
                const deficit = document.createElement('div');
                deficit.className = 'descanso-deficit';
                const deficitHoras = formatDuration(config.descansoReglamentario - descansoMinutos);
                
                // Destacar si es cr√≠tico
                if (descansoMinutos < config.descansoMinimo) {
                  deficit.innerHTML = `<i class="fas fa-exclamation-triangle"></i> <strong>Incompleix descans</strong><br><strong>D√®ficit: ${deficitHoras}</strong>`;
                  deficit.style.borderColor = '#c62828';
                  deficit.style.background = 'linear-gradient(135deg, #ffcdd2 0%, #ef9a9a 100%)';
                } else {
                  deficit.innerHTML = `<strong>Incompleix descans</strong><br><strong>D√®ficit: ${deficitHoras}</strong>`;
                }
                
                descansoIndicator.appendChild(deficit);
              } else {
                // Cumple reglamentario
                const ok = document.createElement('div');
                ok.className = 'descanso-ok';
                ok.innerHTML = '<i class="fas fa-check-circle"></i> <strong>Compleix descans</strong>';
                descansoIndicator.appendChild(ok);
              }
              
              // A√±adir a la secuencia
              secuenciaContainer.appendChild(descansoIndicator);

              // Segunda flecha
              const arrow2 = document.createElement('div');
              arrow2.className = 'arrow';
              arrow2.innerHTML = '<i class="fas fa-long-arrow-alt-right"></i>';
              secuenciaContainer.appendChild(arrow2);
            }
          }
        });
        
        // A√±adir secuencia al contenedor
        elementos.calendarView.appendChild(secuenciaContainer);
        
        // Mostrar secci√≥n
        elementos.calendarSection.style.display = 'block';
      } catch (error) {
        console.error("Error al renderizar horario adaptado:", error);
        
        // Mostrar mensaje de error
        elementos.calendarView.innerHTML = `
          <div style="color: var(--color-warning); padding: 10px;">
            <i class="fas fa-exclamation-triangle"></i> 
            Error en generar l'horari adaptat: ${error.message}
          </div>`;
      }
    }

    /* ======== MOSTRAR/OCULTAR RESULTADOS ======== */
    /**
     * Oculta todas las secciones de resultados
     */
    function hideResults() {
      try {
        elementos.resultsSection.style.display = 'none';
        elementos.recommendationsSection.style.display = 'none';
        elementos.calendarSection.style.display = 'none';
        
        // Limpiar datos de resultados
        ultimoAnalisis = null;
        deficitsDetallados = [];
        currentDeficitMinutes = 0;
      } catch (error) {
        console.error("Error al ocultar resultados:", error);
      }
    }
  </script>
  <script>
    /* ======== MODAL ======== */
    /**
     * Muestra el modal para seleccionar turnos con animaci√≥n
     */
    function showModal() {
      try {
        // Mostrar modal con animaci√≥n
        elementos.turnoModal.style.display = 'flex';
        
        // Animar el contenido
        const modalContent = elementos.turnoModal.querySelector('div');
        if (modalContent) {
          modalContent.style.opacity = '0';
          modalContent.style.transform = 'translateY(20px)';
          
          // Aplicar animaci√≥n con peque√±o retraso para mejor efecto
          setTimeout(() => {
            modalContent.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
            modalContent.style.opacity = '1';
            modalContent.style.transform = 'translateY(0)';
          }, 10);
        }
      } catch (error) {
        console.error("Error al mostrar modal:", error);
        mostrarMensaje("No s'ha pogut mostrar el selector de torns", "error");
      }
    }

    /**
     * Cierra el modal con animaci√≥n
     */
    function closeModal() {
      try {
        const modalContent = elementos.turnoModal.querySelector('div');
        
        if (modalContent) {
          // Animar salida
          modalContent.style.transition = 'opacity 0.2s ease, transform 0.2s ease';
          modalContent.style.opacity = '0';
          modalContent.style.transform = 'translateY(20px)';
          
          // Ocultar modal despu√©s de la animaci√≥n
          setTimeout(() => {
            elementos.turnoModal.style.display = 'none';
            
            // Restablecer estilos para la pr√≥xima apertura
            modalContent.style.transition = '';
            modalContent.style.opacity = '';
            modalContent.style.transform = '';
          }, 200);
        } else {
          elementos.turnoModal.style.display = 'none';
        }
      } catch (error) {
        console.error("Error al cerrar modal:", error);
        
        // En caso de error, forzar cierre sin animaci√≥n
        elementos.turnoModal.style.display = 'none';
      }
    }

    /* ======== KEYPRESS HANDLERS ======== */
    /**
     * Manejador de eventos para teclas
     */
    function setupKeyboardEvents() {
      try {
        // Cerrar modal con tecla Escape
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && elementos.turnoModal.style.display === 'flex') {
            closeModal();
          }
        });
        
        // Cerrar modal al hacer clic fuera del contenido
        elementos.turnoModal.addEventListener('click', (e) => {
          if (e.target === elementos.turnoModal) {
            closeModal();
          }
        });
      } catch (error) {
        console.error("Error al configurar eventos de teclado:", error);
      }
    }

    /* ======== FUNCIONES DE EXPORTACI√ìN ======== */
    /**
     * Genera datos de secuencia para exportar/compartir
     * @returns {object} Datos de la secuencia actual
     */
    function generarDatosExportacion() {
      try {
        // No exportar si no hay turnos
        if (turnos.length === 0) {
          return null;
        }
        
        // Crear objeto con todos los datos necesarios
        const datos = {
          version: "2.0",
          fecha: new Date().toISOString(),
          turnos: turnos,
          analisis: ultimoAnalisis,
          deficits: deficitsDetallados,
          compensaciones: document.querySelector('.compensation-option.selected') ? {
            turnosRecomendados: JSON.parse(document.querySelector('.compensation-option.selected').dataset.turns || '[]'),
            recuperacion: document.querySelector('.compensation-option.selected').dataset.recovery || '0:00'
          } : null
        };
        
        return datos;
      } catch (error) {
        console.error("Error al generar datos para exportaci√≥n:", error);
        mostrarMensaje("Error en generar dades per compartir", "error");
        return null;
      }
    }

    /**
     * Importa una secuencia de turnos previamente guardada
     * @param {object} datos - Datos de la secuencia a importar
     * @returns {boolean} Si la importaci√≥n fue exitosa
     */
    function importarSecuencia(datos) {
      try {
        // Validar formato de datos
        if (!datos || !datos.version || !Array.isArray(datos.turnos) || datos.turnos.length === 0) {
          throw new Error("Formato de datos inv√°lido");
        }
        
        // Validar tipos de turnos
        if (!datos.turnos.every(turno => ['M', 'T', 'DD', 'FS'].includes(turno))) {
          throw new Error("Secuencia contiene turnos no v√°lidos");
        }
        
        // Limpiar secuencia actual
        turnos = [];
        deficitsDetallados = [];
        ultimoAnalisis = null;
        
        // Importar turnos
        turnos = [...datos.turnos];
        
        // Renderizar y analizar
        renderTurnos();
        
        if (turnos.length > 1) {
          analyzeSequence();
        } else {
          hideResults();
        }
        
        mostrarMensaje("Seq√º√®ncia importada correctament", "success");
        return true;
      } catch (error) {
        console.error("Error al importar secuencia:", error);
        mostrarMensaje(`Error en importar seq√º√®ncia: ${error.message}`, "error");
        return false;
      }
    }

    /* ======== INICIALIZACI√ìN ======== */
    /**
     * Initializa la aplicaci√≥n
     */
    function init() {
      try {
        // Obtener referencias DOM actualizadas (por si hay cambios din√°micos)
        elementos.turnoSequence = document.getElementById('turno-sequence');
        elementos.turnoModal = document.getElementById('turnoModal');
        elementos.resultsSection = document.getElementById('results');
        elementos.recommendationsSection = document.getElementById('recommendations');
        elementos.calendarSection = document.getElementById('calendar');
        elementos.calendarView = document.getElementById('calendar-view');
        elementos.infoMessages = document.getElementById('info-messages');
        elementos.btnAddTurno = document.getElementById('add-turno');
        elementos.btnClearTurnos = document.getElementById('clear-turnos');
        elementos.deficitTotal = document.getElementById('deficit-total');
        elementos.compensacionRequerida = document.getElementById('compensacion-requerida');
        elementos.transicionesDeficitarias = document.getElementById('transiciones-deficitarias');
        elementos.patternBox = document.getElementById('pattern-box');
        elementos.patternName = document.getElementById('pattern-name');
        elementos.patternDescription = document.getElementById('pattern-description');
        elementos.recommendationText = document.getElementById('recommendation-text');
        elementos.compensationOptions = document.getElementById('compensation-options');
        
        // Configurar eventos de teclado
        setupKeyboardEvents();
        
        // Mensaje de bienvenida
        mostrarMensaje("Benvingut a la Calculadora de Descansos. Afegeix torns per comen√ßar l'an√†lisi.", "info", 5000);
        
        // Comprobar si hay datos guardados en localStorage
        try {
          const datosGuardados = localStorage.getItem('calculadoraDescansos');
          if (datosGuardados) {
            const datos = JSON.parse(datosGuardados);
            if (datos && Array.isArray(datos.turnos) && datos.turnos.length > 0) {
              // Preguntar si desea cargar los datos guardados
              const cargar = confirm("S'han trobat dades guardades d'una sessi√≥ anterior. Vols carregar-les?");
              if (cargar) {
                importarSecuencia(datos);
              } else {
                localStorage.removeItem('calculadoraDescansos');
              }
            }
          }
        } catch (e) {
          console.error("Error al cargar datos guardados:", e);
          localStorage.removeItem('calculadoraDescansos');
        }
        
        // Renderizar el estado inicial (mostrar√° el bot√≥n "+" si est√° vac√≠o)
        renderTurnos();
        
        // Ejemplo inicial (opcional - puedes descomentar estas l√≠neas para empezar con turnos de ejemplo)
        // if (turnos.length === 0) {
        //   addTurnoType('T');
        //   addTurnoType('M');
        //   addTurnoType('T');
        // }
      } catch (error) {
        console.error("Error en inicializaci√≥n:", error);
        alert("Ha ocorregut un error en inicialitzar l'aplicaci√≥. Si us plau, recarrega la p√†gina.");
      }
    }

    /**
     * Guardar estado antes de cerrar/recargar p√°gina
     */
    function setupBeforeUnload() {
      window.addEventListener('beforeunload', () => {
        try {
          // Solo guardar si hay turnos
          if (turnos.length > 0) {
            const datos = generarDatosExportacion();
            if (datos) {
              localStorage.setItem('calculadoraDescansos', JSON.stringify(datos));
            }
          }
        } catch (e) {
          console.error("Error al guardar estado:", e);
        }
      });
    }

    // Configurar evento antes de cerrar
    setupBeforeUnload();
    
    // Inicializar la aplicaci√≥n cuando se cargue el DOM
    document.addEventListener('DOMContentLoaded', init);
    
    // Si el DOM ya est√° cargado, inicializar inmediatamente
    if (document.readyState === 'interactive' || document.readyState === 'complete') {
      init();
    }
  </script>

  <script>
    /* ======== M√ìDULO DE COMPROBACI√ìN DE HORARIOS ======== */
    
    // Variables globales del m√≥dulo
    let datosTabla = []; // Almacena los datos parseados de la tabla
    let resultadosAnalisis = []; // Resultados del an√°lisis por trabajador
    let encabezadosPersonalizados = []; // Encabezados personalizados de la tabla
    
    // Sistema de deshacer/rehacer
    let historialCambios = []; // Stack de estados previos
    let historialRehacer = []; // Stack para rehacer
    let estadoInicial = null; // Estado inicial de la tabla
    const MAX_HISTORIAL = 50; // M√°ximo de cambios en historial
    
    // Referencias DOM
    const elementosCheck = {
      tablaBody: document.getElementById('tabla-body'),
      btnRevisar: document.getElementById('btn-revisar-horarios'),
      btnCopiar: document.getElementById('btn-copiar-tabla'),
      btnLimpiar: document.getElementById('btn-limpiar-tabla'),
      btnAfegirFila: document.getElementById('btn-afegir-fila'),
      resultadosComprobacion: document.getElementById('resultados-comprobacion'),
      resumenGeneral: document.getElementById('resumen-general'),
      informesIndividuales: document.getElementById('informes-individuales')
    };

    /**
     * Captura el estado actual de la tabla
     */
    function capturarEstadoTabla() {
      const filas = elementosCheck.tablaBody.querySelectorAll('tr');
      const estado = [];
      
      filas.forEach(fila => {
        const celdas = fila.querySelectorAll('td');
        const filaData = [];
        celdas.forEach(celda => {
          filaData.push(celda.textContent.trim());
        });
        estado.push(filaData);
      });
      
      return JSON.stringify(estado);
    }
    
    /**
     * Restaura un estado previo de la tabla
     */
    function restaurarEstadoTabla(estadoJSON) {
      try {
        const estado = JSON.parse(estadoJSON);
        
        // Limpiar tabla actual
        elementosCheck.tablaBody.innerHTML = '';
        
        // Recrear filas con el estado guardado
        estado.forEach(filaData => {
          crearFilaTabla(filaData);
        });
        
      } catch (error) {
        console.error('Error al restaurar estado:', error);
      }
    }
    
    /**
     * Guarda el estado actual antes de un cambio
     */
    function guardarEstadoAntesDeCambio() {
      const estadoActual = capturarEstadoTabla();
      
      // Si es diferente del √∫ltimo estado guardado, lo a√±adimos
      if (historialCambios.length === 0 || historialCambios[historialCambios.length - 1] !== estadoActual) {
        historialCambios.push(estadoActual);
        
        // Limpiar historial de rehacer cuando se hace un nuevo cambio
        historialRehacer = [];
        
        // Limitar tama√±o del historial
        if (historialCambios.length > MAX_HISTORIAL) {
          historialCambios.shift();
        }
      }
    }
    
    /**
     * Deshace el √∫ltimo cambio (Ctrl+Z)
     */
    function deshacerCambio() {
      if (historialCambios.length > 0) {
        // Guardar estado actual para rehacer
        const estadoActual = capturarEstadoTabla();
        historialRehacer.push(estadoActual);
        
        // Obtener y aplicar el estado anterior
        const estadoAnterior = historialCambios.pop();
        restaurarEstadoTabla(estadoAnterior);
        
        // Feedback visual
        mostrarFeedbackAccion('‚Ü∂ Desfer', '#2196f3');
        
        console.log(`Deshacer aplicado. Estados en historial: ${historialCambios.length}`);
      } else {
        mostrarFeedbackAccion('No hi ha m√©s canvis per desfer', '#ff9800');
      }
    }
    
    /**
     * Rehace el √∫ltimo cambio deshecho (Ctrl+Y)
     */
    function rehacerCambio() {
      if (historialRehacer.length > 0) {
        // Guardar estado actual en historial
        const estadoActual = capturarEstadoTabla();
        historialCambios.push(estadoActual);
        
        // Obtener y aplicar el estado a rehacer
        const estadoRehacer = historialRehacer.pop();
        restaurarEstadoTabla(estadoRehacer);
        
        // Feedback visual
        mostrarFeedbackAccion('‚Ü∑ Refer', '#4caf50');
        
        console.log(`Rehacer aplicado. Estados para rehacer: ${historialRehacer.length}`);
      } else {
        mostrarFeedbackAccion('No hi ha m√©s canvis per refer', '#ff9800');
      }
    }
    
    /**
     * Muestra feedback visual de una acci√≥n
     */
    function mostrarFeedbackAccion(mensaje, color) {
      // Crear elemento de feedback
      const feedback = document.createElement('div');
      feedback.textContent = mensaje;
      feedback.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${color};
        color: white;
        padding: 12px 20px;
        border-radius: 6px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        z-index: 10000;
        font-weight: 600;
        font-size: 14px;
        animation: slideInRight 0.3s ease;
      `;
      
      document.body.appendChild(feedback);
      
      // Eliminar despu√©s de 2 segundos
      setTimeout(() => {
        feedback.style.animation = 'fadeOut 0.3s ease';
        setTimeout(() => feedback.remove(), 300);
      }, 2000);
    }
    
    /**
     * Configura los event listeners para deshacer/rehacer
     */
    function configurarDeshacerRehacer() {
      // Event listener global para Ctrl+Z y Ctrl+Y
      document.addEventListener('keydown', (e) => {
        // Solo activar si estamos en la pesta√±a de comprobaci√≥n
        const tabComprobacion = document.getElementById('comprobacion');
        if (!tabComprobacion || !tabComprobacion.classList.contains('active')) {
          return;
        }
        
        // Ctrl+Z - Deshacer
        if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
          e.preventDefault();
          deshacerCambio();
        }
        
        // Ctrl+Y o Ctrl+Shift+Z - Rehacer
        if ((e.ctrlKey && e.key === 'y') || (e.ctrlKey && e.shiftKey && e.key === 'z')) {
          e.preventDefault();
          rehacerCambio();
        }
      });
      
      // Capturar cambios en las celdas editables
      const tabla = document.getElementById('tabla-horarios');
      if (tabla) {
        // Usar delegaci√≥n de eventos para capturar cambios en celdas
        let contenidoAnterior = '';
        
        tabla.addEventListener('focusin', (e) => {
          if (e.target.tagName === 'TD' && e.target.isContentEditable) {
            contenidoAnterior = e.target.textContent;
          }
        });
        
        tabla.addEventListener('focusout', (e) => {
          if (e.target.tagName === 'TD' && e.target.isContentEditable) {
            const contenidoNuevo = e.target.textContent;
            // Solo guardar si realmente cambi√≥
            if (contenidoAnterior !== contenidoNuevo) {
              guardarEstadoAntesDeCambio();
            }
          }
        });
        
        // Tambi√©n capturar cambios al presionar Enter
        tabla.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && e.target.tagName === 'TD' && e.target.isContentEditable) {
            e.preventDefault();
            guardarEstadoAntesDeCambio();
            e.target.blur();
          }
        });
      }
    }
    
    /**
     * Inicializa el m√≥dulo de comprobaci√≥n de horarios
     */
    function initComprobacion() {
      try {
        // Event listeners para botones
        elementosCheck.btnRevisar.addEventListener('click', analizarHorarios);
        elementosCheck.btnCopiar.addEventListener('click', copiarTablaConFormato);
        elementosCheck.btnLimpiar.addEventListener('click', limpiarTabla);
        elementosCheck.btnAfegirFila.addEventListener('click', afegirFilaTabla);
        
        // Evento para detectar pegado en la tabla
        const tabla = document.getElementById('tabla-horarios');
        if (tabla) {
          tabla.addEventListener('paste', manejarPegado);
        }
        
        // Configurar sistema de deshacer/rehacer
        configurarDeshacerRehacer();
        
        // Capturar estado inicial
        setTimeout(() => {
          estadoInicial = capturarEstadoTabla();
          historialCambios.push(estadoInicial);
        }, 100);
        
        console.log('M√≥dulo de comprobaci√≥n inicializado correctamente');
        console.log('‚úÖ Ctrl+Z (deshacer) y Ctrl+Y (rehacer) activados');
      } catch (error) {
        console.error('Error al inicializar m√≥dulo de comprobaci√≥n:', error);
      }
    }

    /**
     * Copia la tabla con formato HTML para pegar en Excel/Word
     */
    async function copiarTablaConFormato() {
      try {
        const tabla = document.getElementById('tabla-horarios');
        if (!tabla) {
          alert('No se encontr√≥ la tabla');
          return;
        }
        
        // Crear clon de la tabla para procesar
        const tablaClone = tabla.cloneNode(true);
        
        // Eliminar tooltips y flechas del clon (solo queremos la tabla visual)
        tablaClone.querySelectorAll('.tooltip-descanso, .flecha-deficit').forEach(el => el.remove());
        
        // Generar HTML con estilos inline para compatibilidad con Excel
        let html = '<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse; font-family: Arial, sans-serif; font-size: 11px;">';
        
        // Procesar thead
        const thead = tablaClone.querySelector('thead');
        if (thead) {
          html += '<thead>';
          thead.querySelectorAll('tr').forEach(tr => {
            html += '<tr>';
            tr.querySelectorAll('th').forEach(th => {
              const texto = th.textContent.trim();
              html += `<th style="background-color: #0078d4; color: white; font-weight: bold; text-align: center; padding: 8px;">${texto}</th>`;
            });
            html += '</tr>';
          });
          html += '</thead>';
        }
        
        // Procesar tbody
        const tbody = tablaClone.querySelector('tbody');
        if (tbody) {
          html += '<tbody>';
          tbody.querySelectorAll('tr').forEach(tr => {
            html += '<tr>';
            tr.querySelectorAll('td').forEach((td, index) => {
              const texto = td.textContent.trim();
              let estilo = 'padding: 6px; text-align: center;';
              
              // Primera columna (nombre del trabajador)
              if (index === 0) {
                estilo = 'padding: 6px; text-align: left; font-weight: 500; background-color: #f8f9fa;';
              }
              
              // Aplicar estilos seg√∫n las clases
              if (td.classList.contains('deficit')) {
                estilo += ' background-color: rgba(244, 67, 54, 0.35); color: #c62828; font-weight: bold; border: 4px solid #ef5350; box-shadow: 0 0 0 2px rgba(244, 67, 54, 0.2), 0 2px 6px rgba(183, 28, 28, 0.25);';
              } else if (td.classList.contains('compensado')) {
                estilo += ' background-color: rgba(229, 115, 115, 0.35); color: #d32f2f; font-weight: 600; border: 3px solid #e57373; box-shadow: 0 0 0 1px rgba(229, 115, 115, 0.2), 0 1px 4px rgba(198, 40, 40, 0.2);';
              } else if (td.classList.contains('fs-dia')) {
                estilo += ' background: transparent; color: #9575CD; font-weight: 600;';
              }
              
              html += `<td style="${estilo}">${texto}</td>`;
            });
            html += '</tr>';
          });
          html += '</tbody>';
        }
        
        html += '</table>';
        
        // Crear texto plano como fallback
        let textoPlano = '';
        tabla.querySelectorAll('tr').forEach(tr => {
          const celdas = Array.from(tr.querySelectorAll('th, td')).map(celda => 
            celda.textContent.trim()
          );
          textoPlano += celdas.join('\t') + '\n';
        });
        
        // Copiar al portapapeles con ambos formatos
        const blobHtml = new Blob([html], { type: 'text/html' });
        const blobText = new Blob([textoPlano], { type: 'text/plain' });
        
        const clipboardItem = new ClipboardItem({
          'text/html': blobHtml,
          'text/plain': blobText
        });
        
        await navigator.clipboard.write([clipboardItem]);
        
        // Feedback visual
        const btnCopiar = elementosCheck.btnCopiar;
        const textoOriginal = btnCopiar.innerHTML;
        btnCopiar.innerHTML = '<i class="fas fa-check"></i> Copiat!';
        btnCopiar.style.backgroundColor = '#4caf50';
        
        setTimeout(() => {
          btnCopiar.innerHTML = textoOriginal;
          btnCopiar.style.backgroundColor = '';
        }, 2000);
        
        console.log('Tabla copiada con formato correctamente');
      } catch (error) {
        console.error('Error al copiar tabla:', error);
        
        // Fallback: intentar copiar solo texto
        try {
          const tabla = document.getElementById('tabla-horarios');
          const range = document.createRange();
          range.selectNode(tabla);
          window.getSelection().removeAllRanges();
          window.getSelection().addRange(range);
          document.execCommand('copy');
          window.getSelection().removeAllRanges();
          
          alert('Tabla copiada (sin formato avanzado). Pega en Excel.');
        } catch (e) {
          alert('No se pudo copiar la tabla. Por favor, selecciona manualmente y copia con Ctrl+C');
        }
      }
    }

    /**
     * Exporta el informe individual de un trabajador en formato Excel
     */
    async function exportarInformeIndividual(indice) {
      try {
        const resultado = resultadosAnalisis[indice];
        if (!resultado) {
          alert('No se encontr√≥ el informe');
          return;
        }
        
        const { nombre, netDeficit, numDeficits, cumplimiento, deficits, tieneDeficit, turnos } = resultado;
        
        // Calcular d√©ficit total original y compensado
        const deficitTotalOriginal = deficits.reduce((sum, d) => sum + (d.deficitOriginal || d.deficit), 0);
        const deficitCompensado = deficitTotalOriginal - netDeficit;
        
        // Generar HTML para tabla Excel
        let html = '<html><head><meta charset="utf-8"></head><body>';
        
        // T√≠tulo del informe
        html += `
          <h2 style="color: #0078d4; font-family: Arial, sans-serif; margin-bottom: 10px;">
            üìã INFORME DE DESCANSOS: ${nombre}
          </h2>
        `;
        
        // NUEVA SECCI√ìN: Calendario visual de turnos con d√≠as marcados
        html += `
          <table border="1" cellpadding="6" cellspacing="0" style="border-collapse: collapse; font-family: Arial, sans-serif; font-size: 10px; margin-bottom: 20px; width: 100%;">
            <thead>
              <tr style="background-color: #0078d4; color: white; font-weight: bold;">
                <th colspan="${Math.min(turnos.length + 1, 32)}" style="text-align: left; padding: 8px;">
                  üìÖ CALENDARI DE TORNS - DIES AMB INCOMPLIMENTS MARCATS EN VERMELL
                </th>
              </tr>
              <tr style="background-color: #0078d4; color: white; font-weight: bold; text-align: center;">
                <th style="padding: 6px; min-width: 80px;">Treballador</th>
        `;
        
        // Crear identificador de columnas con d√©ficit
        const columnasConDeficit = new Set();
        deficits.forEach(deficit => {
          if (deficit.deficitOriginal || deficit.deficit > 0) {
            columnasConDeficit.add(deficit.indice);
            columnasConDeficit.add(deficit.indice + 1);
          }
        });
        
        // Headers de d√≠as (usar encabezados personalizados si existen)
        turnos.forEach((turno, idx) => {
          const diaNum = idx + 1;
          const tieneDeficit = columnasConDeficit.has(idx);
          const bgColor = tieneDeficit ? '#c62828' : '#0078d4';
          const icon = tieneDeficit ? '‚ö†Ô∏è' : '';
          
          // Usar encabezado personalizado si existe, sino usar D1, D2, etc.
          const etiquetaDia = (encabezadosPersonalizados && encabezadosPersonalizados[idx + 1]) 
            ? encabezadosPersonalizados[idx + 1] 
            : `D${diaNum}`;
          
          html += `<th style="padding: 6px; background-color: ${bgColor}; color: white; font-weight: bold; text-align: center; min-width: 45px;">
            ${icon} ${etiquetaDia}
          </th>`;
        });
        
        html += `
              </tr>
            </thead>
            <tbody>
              <tr>
                <td style="background-color: #f8f9fa; font-weight: 600; padding: 6px;">${nombre}</td>
        `;
        
        // Celdas de turnos con colores
        turnos.forEach((turno, idx) => {
          const tieneDeficit = columnasConDeficit.has(idx);
          let bgColor = 'white';
          let textColor = '#333';
          let borderColor = '#ddd';
          let estiloExtra = '';
          
          // Primero verificar si es FS
          if (turno === 'FS') {
            bgColor = 'transparent';
            textColor = '#9575CD';
            borderColor = '#ddd';
            estiloExtra = '';
          }
          
          // Luego, si tiene d√©ficit, sobreescribir
          if (tieneDeficit) {
            bgColor = 'rgba(244, 67, 54, 0.35)';
            textColor = '#c62828';
            borderColor = '#ef5350';
            estiloExtra = 'box-shadow: 0 0 0 2px rgba(244, 67, 54, 0.2), 0 2px 6px rgba(183, 28, 28, 0.25);';
          }
          
          html += `<td style="${estiloExtra} background-color: ${bgColor}; color: ${textColor}; font-weight: bold; text-align: center; padding: 6px; border: ${tieneDeficit ? '4px' : '2px'} solid ${borderColor};">
            ${turno}
          </td>`;
        });
        
        html += `
              </tr>
            </tbody>
          </table>
        `;
        
        // Tabla de estad√≠sticas generales
        html += `
          <table border="1" cellpadding="8" cellspacing="0" style="border-collapse: collapse; font-family: Arial, sans-serif; font-size: 11px; margin-bottom: 20px;">
            <thead>
              <tr style="background-color: #0078d4; color: white; font-weight: bold;">
                <th colspan="2" style="text-align: left; padding: 10px;">RESUM ESTAD√çSTIC</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td style="background-color: #f8f9fa; font-weight: 600; width: 200px;">Estat General</td>
                <td style="background-color: ${tieneDeficit ? '#ffebee' : '#e8f5e9'}; color: ${tieneDeficit ? '#c62828' : '#2e7d32'}; font-weight: bold;">
                  ${tieneDeficit ? '‚ùå AMB D√àFICIT' : '‚úÖ COMPLEIX'}
                </td>
              </tr>
              <tr>
                <td style="background-color: #f8f9fa; font-weight: 600;">D√®ficit Total Original</td>
                <td style="font-weight: bold; color: ${deficitTotalOriginal > 0 ? '#c62828' : '#2e7d32'};">
                  ${formatDuration(deficitTotalOriginal)}
                </td>
              </tr>
              <tr>
                <td style="background-color: #f8f9fa; font-weight: 600;">D√®ficit Compensat</td>
                <td style="font-weight: bold; color: #f57f17;">
                  ${formatDuration(deficitCompensado)}
                </td>
              </tr>
              <tr>
                <td style="background-color: #f8f9fa; font-weight: 600;">D√®ficit Net Final</td>
                <td style="font-weight: bold; color: ${netDeficit > 0 ? '#c62828' : '#2e7d32'};">
                  ${formatDuration(netDeficit)}
                </td>
              </tr>
              <tr>
                <td style="background-color: #f8f9fa; font-weight: 600;">Transicions Deficit√†ries</td>
                <td style="font-weight: bold;">
                  ${numDeficits}
                </td>
              </tr>
              <tr>
                <td style="background-color: #f8f9fa; font-weight: 600;">% Compliment</td>
                <td style="font-weight: bold; color: ${cumplimiento >= 80 ? '#2e7d32' : (cumplimiento >= 60 ? '#f57f17' : '#c62828')};">
                  ${cumplimiento}%
                </td>
              </tr>
            </tbody>
          </table>
        `;
        
        // Tabla de detalle de d√©ficits (solo si hay)
        if (tieneDeficit && deficits.length > 0) {
          html += `
            <table border="1" cellpadding="8" cellspacing="0" style="border-collapse: collapse; font-family: Arial, sans-serif; font-size: 11px; margin-top: 15px; width: 100%;">
              <thead>
                <tr style="background-color: #ef5350; color: white; font-weight: bold;">
                  <th colspan="8" style="text-align: left; padding: 10px;">
                    ‚ö†Ô∏è DETALL DELS INCOMPLIMENTS DE DESCANS - LOCALITZACI√ì PER DIES
                  </th>
                </tr>
                <tr style="background-color: #0078d4; color: white; font-weight: bold; font-size: 10px;">
                  <th style="text-align: center; padding: 8px;">#</th>
                  <th style="text-align: center; padding: 8px;">Dia Inici</th>
                  <th style="text-align: center; padding: 8px;">Torn Inici</th>
                  <th style="text-align: center; padding: 8px;">‚Üí</th>
                  <th style="text-align: center; padding: 8px;">Dia Final</th>
                  <th style="text-align: center; padding: 8px;">Torn Final</th>
                  <th style="text-align: center; padding: 8px;">Descans / D√®ficit</th>
                  <th style="text-align: center; padding: 8px;">Estat</th>
                </tr>
              </thead>
              <tbody>
          `;
          
          deficits.forEach((deficit, idx) => {
            const { indice, turnoActual, turnoSiguiente, deficitOriginal, deficit: deficitMinutos, compensado, descansoActual } = deficit;
            const deficitAMostrar = deficitOriginal || deficitMinutos;
            const estadoTexto = compensado ? '‚úÖ Compensat' : '‚ùå Pendent';
            const estadoColor = compensado ? 'white' : 'white';
            const estadoBg = compensado ? '#ef5350' : '#f44336';
            
            const diaInicio = indice + 1; // D√≠a donde empieza el turno
            const diaFinal = indice + 2;  // D√≠a del siguiente turno
            
            // Usar encabezados personalizados si existen
            const etiquetaDiaInicio = (encabezadosPersonalizados && encabezadosPersonalizados[diaInicio]) 
              ? encabezadosPersonalizados[diaInicio] 
              : `D${diaInicio}`;
            const etiquetaDiaFinal = (encabezadosPersonalizados && encabezadosPersonalizados[diaFinal]) 
              ? encabezadosPersonalizados[diaFinal] 
              : `D${diaFinal}`;
            
            html += `
              <tr style="background-color: ${compensado ? '#ffebee' : '#fff5f5'};">
                <td style="text-align: center; font-weight: bold; background-color: #f8f9fa; font-size: 12px;">${idx + 1}</td>
                <td style="text-align: center; font-weight: bold; background-color: #ffebee; color: #c62828; font-size: 12px;">
                  ${etiquetaDiaInicio}
                </td>
                <td style="text-align: center; font-weight: bold; font-size: 14px; color: #c62828;">
                  ${turnoActual}
                </td>
                <td style="text-align: center; font-weight: bold; color: #666; font-size: 16px;">
                  ‚Üí
                </td>
                <td style="text-align: center; font-weight: bold; background-color: #ffebee; color: #c62828; font-size: 12px;">
                  ${etiquetaDiaFinal}
                </td>
                <td style="text-align: center; font-weight: bold; font-size: 14px; color: #c62828;">
                  ${turnoSiguiente}
                </td>
                <td style="text-align: center; padding: 8px;">
                  <div style="margin-bottom: 4px;">
                    <strong>Descans:</strong> <span style="color: #666;">${formatDuration(descansoActual)}</span>
                  </div>
                  <div>
                    <strong style="color: #c62828;">D√®ficit:</strong> <span style="color: #c62828; font-weight: bold; font-size: 12px;">${formatDuration(deficitAMostrar)}</span>
                  </div>
                </td>
                <td style="text-align: center; font-weight: bold; color: ${estadoColor}; background-color: ${estadoBg}; font-size: 11px;">
                  ${estadoTexto}
                </td>
              </tr>
            `;
          });
          
          html += `
              </tbody>
            </table>
          `;
          
          // A√±adir leyenda explicativa
          html += `
            <div style="margin-top: 15px; padding: 12px; background-color: #fff9e6; border-left: 4px solid #f57f17; border-radius: 4px; font-family: Arial, sans-serif; font-size: 10px;">
              <strong style="color: #f57f17;">üí° Com interpretar aquesta taula:</strong>
              <ul style="margin: 8px 0 0 20px; color: #666;">
                <li><strong>Dia Inici/Final:</strong> Identifica exactament entre quins dies es produeix l'incompliment</li>
                <li><strong>Descans Real:</strong> Temps de descans efectiu entre els dos torns</li>
                <li><strong>D√®ficit:</strong> Difer√®ncia respecte al descans reglamentari de 12 hores</li>
                <li><strong>‚ö†Ô∏è Dies marcats en vermell al calendari:</strong> Dies involucrats en incompliments</li>
              </ul>
            </div>
          `;
        } else {
          html += `
            <div style="padding: 15px; background-color: #e8f5e9; border-left: 4px solid #2e7d32; border-radius: 4px; margin-top: 15px; font-family: Arial, sans-serif;">
              <strong style="color: #2e7d32;">‚úÖ Aquest treballador compleix amb tots els per√≠odes de descans reglamentaris.</strong>
            </div>
          `;
        }
        
        html += '</body></html>';
        
        // Crear texto plano como fallback
        let textoPlano = `üìã INFORME DE DESCANSOS: ${nombre}\n\n`;
        
        textoPlano += `üìÖ CALENDARI DE TORNS:\n`;
        textoPlano += `Dies amb incompliments: `;
        const diasProblematicos = Array.from(columnasConDeficit).map(idx => `D${idx + 1}`).join(', ');
        textoPlano += diasProblematicos || 'Cap';
        textoPlano += `\n`;
        textoPlano += `Seq√º√®ncia: ${turnos.join(' - ')}\n\n`;
        
        textoPlano += `RESUM ESTAD√çSTIC:\n`;
        textoPlano += `Estat General: ${tieneDeficit ? '‚ùå AMB D√àFICIT' : '‚úÖ COMPLEIX'}\n`;
        textoPlano += `D√®ficit Total Original: ${formatDuration(deficitTotalOriginal)}\n`;
        textoPlano += `D√®ficit Compensat: ${formatDuration(deficitCompensado)}\n`;
        textoPlano += `D√®ficit Net Final: ${formatDuration(netDeficit)}\n`;
        textoPlano += `Transicions Deficit√†ries: ${numDeficits}\n`;
        textoPlano += `% Compliment: ${cumplimiento}%\n\n`;
        
        if (tieneDeficit && deficits.length > 0) {
          textoPlano += `‚ö†Ô∏è DETALL DELS INCOMPLIMENTS (LOCALITZACI√ì PER DIES):\n`;
          textoPlano += `${'='.repeat(70)}\n`;
          deficits.forEach((deficit, idx) => {
            const { indice, turnoActual, turnoSiguiente, deficitOriginal, deficit: deficitMinutos, compensado, descansoActual } = deficit;
            const deficitAMostrar = deficitOriginal || deficitMinutos;
            const diaInicio = indice + 1;
            const diaFinal = indice + 2;
            textoPlano += `\n${idx + 1}. D${diaInicio} (${turnoActual}) ‚Üí D${diaFinal} (${turnoSiguiente})\n`;
            textoPlano += `   Descans Real: ${formatDuration(descansoActual)}\n`;
            textoPlano += `   D√®ficit: ${formatDuration(deficitAMostrar)}\n`;
            textoPlano += `   Estat: ${compensado ? '‚úÖ Compensat' : '‚ùå Pendent'}\n`;
          });
        }
        
        // Copiar al portapapeles
        const blobHtml = new Blob([html], { type: 'text/html' });
        const blobText = new Blob([textoPlano], { type: 'text/plain' });
        
        const clipboardItem = new ClipboardItem({
          'text/html': blobHtml,
          'text/plain': blobText
        });
        
        await navigator.clipboard.write([clipboardItem]);
        
        // Feedback visual en el bot√≥n
        const boton = document.querySelector(`[data-indice="${indice}"] .btn-exportar-informe`);
        if (boton) {
          const textoOriginal = boton.innerHTML;
          boton.innerHTML = '<i class="fas fa-check"></i> Copiat!';
          boton.style.backgroundColor = '#4caf50';
          
          setTimeout(() => {
            boton.innerHTML = textoOriginal;
            boton.style.backgroundColor = '';
          }, 2000);
        }
        
        console.log(`Informe de ${nombre} copiado correctamente`);
      } catch (error) {
        console.error('Error al exportar informe individual:', error);
        alert('Error al copiar informe. Intenta de nuevo.');
      }
    }

    /**
     * Maneja el evento de pegado desde Excel
     */
    function manejarPegado(e) {
      try {
        e.preventDefault();
        
        // Guardar estado antes de pegar
        guardarEstadoAntesDeCambio();
        
        // Obtener datos del portapapeles
        const clipboardData = e.clipboardData || window.clipboardData;
        const pastedData = clipboardData.getData('text');
        
        if (!pastedData) {
          console.warn('No hay datos para pegar');
          return;
        }
        
        // Parsear datos (asumimos formato TSV de Excel)
        const filas = pastedData.trim().split('\n').map(fila => 
          fila.split('\t').map(celda => celda.trim())
        );
        
        if (filas.length === 0) {
          console.warn('No se encontraron filas v√°lidas');
          return;
        }
        
        // Verificar si la primera fila es encabezado
        const primeraFilaEsEncabezado = filas[0][0].toLowerCase().includes('treballador') || 
                                         filas[0][0].toLowerCase().includes('nom') ||
                                         filas[0][0].toLowerCase().match(/^d\d+$/) || // D1, D2, etc.
                                         filas[0].length > 5; // Si tiene muchas columnas, probablemente sea encabezado
        
        // Si la primera fila es encabezado, actualizar los encabezados de la tabla
        let inicioFilas = 0;
        if (primeraFilaEsEncabezado) {
          inicioFilas = 1;
          // Actualizar encabezados en la tabla
          const thead = document.querySelector('#tabla-horarios thead tr');
          if (thead) {
            const ths = thead.querySelectorAll('th');
            filas[0].forEach((encabezado, idx) => {
              if (idx < ths.length && encabezado) {
                ths[idx].textContent = encabezado;
              }
            });
          }
        }
        
        // Limpiar tabla actual
        elementosCheck.tablaBody.innerHTML = '';
        
        for (let i = inicioFilas; i < filas.length; i++) {
          const fila = filas[i];
          if (fila.length > 0 && fila[0]) { // Solo si hay nombre
            crearFilaTabla(fila);
          }
        }
        
        // Mensaje de √©xito
        console.log(`${filas.length - inicioFilas} filas importadas correctamente`);
        
      } catch (error) {
        console.error('Error al pegar datos:', error);
        alert('Error en processar les dades enganxades. Assegura\'t que el format sigui correcte.');
      }
    }

    /**
     * Crea una fila en la tabla con los datos proporcionados
     */
    function crearFilaTabla(datos = []) {
      try {
        const tr = document.createElement('tr');
        
        // Primera columna: nombre del trabajador
        const tdNombre = document.createElement('td');
        tdNombre.contentEditable = 'true';
        tdNombre.className = 'col-nombre';
        tdNombre.textContent = datos[0] || '';
        tr.appendChild(tdNombre);
        
        // Columnas de turnos (hasta 31 d√≠as)
        for (let i = 1; i <= 31; i++) {
          const td = document.createElement('td');
          td.contentEditable = 'true';
          td.className = 'col-turno';
          td.textContent = datos[i] ? datos[i].toUpperCase() : '';
          
          // Validar turno al escribir
          td.addEventListener('blur', function() {
            const valor = this.textContent.trim().toUpperCase();
            if (valor && !['M', 'T', 'DD', 'FS', ''].includes(valor)) {
              this.style.background = '#ffebee';
              setTimeout(() => {
                this.style.background = '';
              }, 1500);
            }
            this.textContent = valor;
          });
          
          tr.appendChild(td);
        }
        
        elementosCheck.tablaBody.appendChild(tr);
      } catch (error) {
        console.error('Error al crear fila:', error);
      }
    }

    /**
     * A√±ade una fila vac√≠a a la tabla
     */
    function afegirFilaTabla() {
      // Guardar estado antes de a√±adir fila
      guardarEstadoAntesDeCambio();
      crearFilaTabla([]);
    }

    /**
     * Limpia toda la tabla
     */
    function limpiarTabla() {
      try {
        if (confirm('Est√†s segur que vols netejar tota la taula?')) {
          // Guardar estado antes de limpiar
          guardarEstadoAntesDeCambio();
          
          // Limpiar marcas visuales primero
          limpiarMarcasTabla();
          
          // Limpiar el tbody
          elementosCheck.tablaBody.innerHTML = '';
          crearFilaTabla([]); // A√±adir una fila vac√≠a
          
          // Ocultar resultados y bot√≥n de copiar
          elementosCheck.resultadosComprobacion.style.display = 'none';
          elementosCheck.btnCopiar.style.display = 'none';
          
          // Limpiar datos
          datosTabla = [];
          resultadosAnalisis = [];
          
          // Reiniciar historial despu√©s de limpiar
          historialRehacer = [];
        }
      } catch (error) {
        console.error('Error al limpiar tabla:', error);
      }
    }

    /**
     * Captura los encabezados personalizados de la tabla
     */
    function capturarEncabezadosTabla() {
      try {
        const thead = document.querySelector('#tabla-horarios thead tr');
        const encabezados = [];
        
        if (thead) {
          const ths = thead.querySelectorAll('th');
          ths.forEach((th, index) => {
            const texto = th.textContent.trim();
            encabezados.push(texto || (index === 0 ? 'Nom' : `D${index}`));
          });
        }
        
        return encabezados;
      } catch (error) {
        console.error('Error al capturar encabezados:', error);
        return [];
      }
    }
    
    /**
     * Parsea los datos de la tabla
     */
    function parsearDatosTabla() {
      try {
        datosTabla = [];
        
        const filas = elementosCheck.tablaBody.querySelectorAll('tr');
        
        filas.forEach((tr, index) => {
          const celdas = tr.querySelectorAll('td');
          
          if (celdas.length === 0) return;
          
          const nombre = celdas[0].textContent.trim();
          
          // Solo procesar si hay nombre
          if (!nombre) return;
          
          const turnos = [];
          for (let i = 1; i < celdas.length; i++) {
            const turno = celdas[i].textContent.trim().toUpperCase();
            if (turno) {
              turnos.push(turno);
            }
          }
          
          // Solo a√±adir si hay al menos 2 turnos
          if (turnos.length >= 2) {
            datosTabla.push({
              indice: index,
              nombre: nombre,
              turnos: turnos,
              celdas: Array.from(celdas) // Guardar referencia a las celdas
            });
          }
        });
        
        return datosTabla;
      } catch (error) {
        console.error('Error al parsear datos de tabla:', error);
        return [];
      }
    }

    /**
     * Analiza los horarios de todos los trabajadores
     */
    function analizarHorarios() {
      try {
        // Capturar encabezados personalizados
        encabezadosPersonalizados = capturarEncabezadosTabla();
        
        // Limpiar marcas anteriores
        limpiarMarcasTabla();
        
        // Parsear datos
        const datos = parsearDatosTabla();
        
        if (datos.length === 0) {
          alert('No hi ha dades per analitzar. Afegeix almenys un treballador amb 2 torns.');
          return;
        }
        
        // Analizar cada trabajador
        resultadosAnalisis = [];
        
        datos.forEach(trabajador => {
          const resultado = analizarTrabajador(trabajador);
          resultadosAnalisis.push(resultado);
        });
        
        // Marcar d√©ficits en la tabla
        marcarDeficitsEnTabla();
        
        // Mostrar resultados
        mostrarResultados();
        
      } catch (error) {
        console.error('Error al analizar horarios:', error);
        alert('Error en analitzar els horaris. Si us plau, comprova les dades.');
      }
    }

    /**
     * Analiza la secuencia de un trabajador
     */
    function analizarTrabajador(trabajador) {
      try {
        const { nombre, turnos, indice, celdas } = trabajador;
        
        // Usar la funci√≥n existente de c√°lculo de d√©ficit
        const resultado = calcularDeficitConCompensacion(turnos);
        const { deficits, deficitsOriginales, netDeficit } = resultado;
        
        // IMPORTANTE: Usar SIEMPRE los d√©ficits originales (antes de compensaci√≥n)
        // Estos incluyen TODOS los d√©ficits, incluso los que luego se compensan
        const todosLosDeficits = deficitsOriginales || deficits;
        const deficitsReales = todosLosDeficits.filter(d => d.deficitOriginal && d.deficitOriginal > 0);
        
        // Calcular estad√≠sticas basadas en d√©ficits ORIGINALES
        const numTransiciones = turnos.length - 1;
        const numDeficits = deficitsReales.length;
        const cumplimiento = numTransiciones > 0 ? ((numTransiciones - numDeficits) / numTransiciones * 100).toFixed(1) : '100.0';
        
        // Identificar posiciones con d√©ficit para marcar en tabla (usar d√©ficits REALES originales)
        const posicionesDeficit = deficitsReales.map(d => ({
          desde: d.indice,
          hasta: d.indice + 1,
          deficit: d.deficitOriginal, // Usar d√©ficit ORIGINAL, no el modificado por compensaci√≥n
          compensado: d.compensado
        }));
        
        return {
          nombre,
          turnos,
          indice,
          celdas,
          deficits: deficitsReales, // Usar d√©ficits reales con d√©ficit original
          netDeficit,
          numTransiciones,
          numDeficits,
          cumplimiento,
          posicionesDeficit,
          tieneDeficit: numDeficits > 0 // Basado en d√©ficits originales, no en d√©ficit neto
        };
      } catch (error) {
        console.error('Error al analizar trabajador:', error);
        return null;
      }
    }

    /**
     * Limpia todas las marcas visuales de la tabla
     */
    function limpiarMarcasTabla() {
      try {
        // Limpiar clases de las celdas
        const todasLasCeldas = document.querySelectorAll('.tabla-editable td.col-turno');
        todasLasCeldas.forEach(celda => {
          celda.classList.remove('deficit', 'compensado', 'ok');
        });
        
        // Eliminar todos los tooltips de descanso
        const tooltips = document.querySelectorAll('.tooltip-descanso');
        tooltips.forEach(tooltip => tooltip.remove());
        
        // Eliminar todas las flechas de d√©ficit
        const flechas = document.querySelectorAll('.flecha-deficit');
        flechas.forEach(flecha => flecha.remove());
      } catch (error) {
        console.error('Error al limpiar marcas:', error);
      }
    }

    /**
     * Marca visualmente los d√©ficits en la tabla y crea tooltips para las celdas con d√©ficit
     */
    function marcarDeficitsEnTabla() {
      try {
        resultadosAnalisis.forEach(resultado => {
          if (!resultado || !resultado.celdas) return;
          
          const celdas = resultado.celdas;
          const { turnos, deficits } = resultado;
          
          // Crear mapa de d√©ficits por √≠ndice para acceso r√°pido
          const mapaDeficits = {};
          deficits.forEach(d => {
            mapaDeficits[d.indice] = d;
          });
          
          // PRIMERO: Marcar todas las celdas FS con estilo especial
          turnos.forEach((turno, idx) => {
            if (turno === 'FS' && celdas[idx + 1]) {
              celdas[idx + 1].classList.add('fs-dia');
            }
          });
          
          // DESPU√âS: Marcar d√©ficits en las celdas (pueden sobreescribir FS si hay d√©ficit)
          resultado.posicionesDeficit.forEach(posDeficit => {
            const { desde, hasta, compensado } = posDeficit;
            
            // Marcar celda "desde" (inicio del bloque)
            if (celdas[desde + 1]) {
              if (compensado) {
                celdas[desde + 1].classList.add('compensado');
                celdas[desde + 1].classList.add('compensado-bloque-inicio');
              } else {
                celdas[desde + 1].classList.add('deficit');
                celdas[desde + 1].classList.add('deficit-bloque-inicio');
              }
            }
            
            // Marcar celda "hasta" (fin del bloque) - solo si es consecutiva
            if (celdas[hasta + 1] && hasta === desde + 1) {
              if (compensado) {
                celdas[hasta + 1].classList.add('compensado');
                celdas[hasta + 1].classList.add('compensado-bloque-fin');
              } else {
                celdas[hasta + 1].classList.add('deficit');
                celdas[hasta + 1].classList.add('deficit-bloque-fin');
              }
            } else if (celdas[hasta + 1]) {
              // Si no son consecutivas, marcar sin formar bloque
              if (compensado) {
                celdas[hasta + 1].classList.add('compensado');
              } else {
                celdas[hasta + 1].classList.add('deficit');
              }
            }
          });
          
          // Crear tooltips y flechas SOLO para las celdas con d√©ficit o compensadas
          resultado.posicionesDeficit.forEach(posDeficit => {
            const { desde, hasta, compensado } = posDeficit;
            
            // A√±adir tooltip a la celda "desde" (la que inicia el d√©ficit)
            const celdaDesde = celdas[desde + 1];
            if (celdaDesde && (celdaDesde.classList.contains('deficit') || celdaDesde.classList.contains('compensado'))) {
              const deficitInfo = mapaDeficits[desde];
              crearTooltipDescanso(celdaDesde, resultado, desde, deficitInfo);
              
              // Crear flecha hacia la siguiente celda si no son consecutivas o si hay d√©ficit
              if (hasta === desde + 1) {
                // Si son consecutivas, crear flecha en la celda "desde"
                crearFlechaDeficit(celdaDesde, compensado);
              }
            }
            
            // A√±adir tooltip a la celda "hasta" (la que termina el d√©ficit)
            const celdaHasta = celdas[hasta + 1];
            if (celdaHasta && (celdaHasta.classList.contains('deficit') || celdaHasta.classList.contains('compensado'))) {
              const deficitInfo = mapaDeficits[desde]; // Usar el d√©ficit del √≠ndice "desde"
              crearTooltipDescanso(celdaHasta, resultado, desde, deficitInfo);
            }
          });
        });
      } catch (error) {
        console.error('Error al marcar d√©ficits:', error);
      }
    }
    
    /**
     * Crea una flecha visual entre dos celdas con d√©ficit
     */
    function crearFlechaDeficit(celda, compensado) {
      try {
        // Verificar si ya existe una flecha (evitar duplicados)
        if (celda.querySelector('.flecha-deficit')) return;
        
        // Crear elemento de flecha
        const flecha = document.createElement('div');
        flecha.className = 'flecha-deficit';
        if (compensado) {
          flecha.classList.add('compensado');
        }
        
        // A√±adir flecha a la celda
        celda.appendChild(flecha);
      } catch (error) {
        console.error('Error al crear flecha de d√©ficit:', error);
      }
    }
    
    /**
     * Crea un tooltip flotante con informaci√≥n de descanso para una celda con d√©ficit
     */
    function crearTooltipDescanso(celda, resultado, indice, deficitInfo) {
      try {
        const { turnos } = resultado;
        
        // Calcular descanso total (incluyendo FS si hay)
        const descansoTotal = calcularDescansoTotalConFS(turnos, indice);
        if (descansoTotal === null) return;
        
        const descansoFormateado = formatDuration(descansoTotal);
        const hayDeficit = deficitInfo && deficitInfo.deficitOriginal > 0;
        
        // Crear tooltip flotante (solo visible al hacer hover)
        const tooltip = document.createElement('div');
        tooltip.className = 'tooltip-descanso';
        if (hayDeficit) {
          tooltip.classList.add('deficit');
        } else {
          tooltip.classList.add('compensado');
        }
        
        // Construir contenido del tooltip con l√≠neas separadas
        let html = '';
        html += `<span class="tooltip-linea"><strong>Descans:</strong> ${descansoFormateado}h</span>`;
        
        if (hayDeficit) {
          const deficitFormateado = formatDuration(deficitInfo.deficitOriginal);
          html += `<span class="tooltip-linea"><strong>D√®ficit:</strong> ${deficitFormateado}h</span>`;
        }
        
        // Info de patr√≥n si existe
        if (deficitInfo && deficitInfo.patron) {
          html += `<span class="tooltip-linea">${deficitInfo.patron}</span>`;
        }
        
        tooltip.innerHTML = html;
        
        // A√±adir tooltip a la celda
        celda.style.position = 'relative';
        celda.appendChild(tooltip);
        
      } catch (error) {
        console.error('Error al crear tooltip de descanso:', error);
      }
    }
    
    /**
     * Calcula el descanso total entre dos turnos, incluyendo FS intermedios
     * @param {array} turnos - Array de turnos
     * @param {number} indiceInicio - √çndice del turno de inicio
     * @returns {number|null} - Minutos de descanso total o null si no aplica
     */
    function calcularDescansoTotalConFS(turnos, indiceInicio) {
      try {
        if (indiceInicio >= turnos.length - 1) return null;
        
        const turnoInicio = turnos[indiceInicio];
        let indiceFin = indiceInicio + 1;
        
        // Si el turno de inicio es FS, no calculamos descanso desde √©l
        if (turnoInicio === 'FS') return null;
        
        // Buscar el siguiente turno que NO sea FS
        while (indiceFin < turnos.length && turnos[indiceFin] === 'FS') {
          indiceFin++;
        }
        
        // Si no hay siguiente turno de trabajo, no calculamos
        if (indiceFin >= turnos.length) return null;
        
        const turnoFin = turnos[indiceFin];
        
        // Calcular descanso base entre los dos turnos de trabajo
        const finTurnoInicio = convertToMinutes(config.horarios[turnoInicio].fin);
        const inicioTurnoFin = convertToMinutes(config.horarios[turnoFin].inicio);
        
        // Calcular n√∫mero de FS intermedios
        const numFS = indiceFin - indiceInicio - 1;
        
        // Calcular tiempo base (sin FS)
        let tiempoBase;
        if (inicioTurnoFin > finTurnoInicio) {
          tiempoBase = inicioTurnoFin - finTurnoInicio;
        } else {
          tiempoBase = (config.minutosDia - finTurnoInicio) + inicioTurnoFin;
        }
        
        // A√±adir d√≠as completos por cada FS (24h = 1440 minutos)
        const tiempoTotal = tiempoBase + (numFS * config.minutosDia);
        
        return tiempoTotal;
      } catch (error) {
        console.error('Error al calcular descanso total con FS:', error);
        return null;
      }
    }
    
    /**
     * Muestra los resultados del an√°lisis
     */
    function mostrarResultados() {
      try {
        // Mostrar secci√≥n de resultados
        elementosCheck.resultadosComprobacion.style.display = 'block';
        
        // Mostrar bot√≥n de copiar
        elementosCheck.btnCopiar.style.display = 'inline-flex';
        
        // Generar resumen general
        generarResumenGeneral();
        
        // Generar informes individuales
        generarInformesIndividuales();
        
        // Scroll suave a resultados
        elementosCheck.resultadosComprobacion.scrollIntoView({ 
          behavior: 'smooth', 
          block: 'start' 
        });
        
      } catch (error) {
        console.error('Error al mostrar resultados:', error);
      }
    }

    /**
     * Genera el resumen general estad√≠stico
     */
    function generarResumenGeneral() {
      try {
        const totalTrabajadores = resultadosAnalisis.length;
        const trabajadoresConDeficit = resultadosAnalisis.filter(r => r.tieneDeficit).length;
        const trabajadoresSinDeficit = totalTrabajadores - trabajadoresConDeficit;
        const porcentajeCumplimiento = ((trabajadoresSinDeficit / totalTrabajadores) * 100).toFixed(1);
        
        const totalTransiciones = resultadosAnalisis.reduce((sum, r) => sum + r.numTransiciones, 0);
        const totalDeficits = resultadosAnalisis.reduce((sum, r) => sum + r.numDeficits, 0);
        
        const html = `
          <h4 style="margin-bottom: 15px; color: var(--color-primary);">
            <i class="fas fa-chart-pie"></i> Resum General
          </h4>
          <div class="resumen-stats">
            <div class="stat-card info">
              <div class="stat-number">${totalTrabajadores}</div>
              <div class="stat-label">Treballadors Analitzats</div>
            </div>
            <div class="stat-card success">
              <div class="stat-number">${trabajadoresSinDeficit}</div>
              <div class="stat-label">Compleixen Descansos</div>
            </div>
            <div class="stat-card warning">
              <div class="stat-number">${trabajadoresConDeficit}</div>
              <div class="stat-label">Amb D√®ficits</div>
            </div>
            <div class="stat-card ${porcentajeCumplimiento >= 80 ? 'success' : 'warning'}">
              <div class="stat-number">${porcentajeCumplimiento}%</div>
              <div class="stat-label">Taxa de Compliment</div>
            </div>
            <div class="stat-card info">
              <div class="stat-number">${totalDeficits}/${totalTransiciones}</div>
              <div class="stat-label">Transicions Deficit√†ries</div>
            </div>
          </div>
        `;
        
        elementosCheck.resumenGeneral.innerHTML = html;
      } catch (error) {
        console.error('Error al generar resumen general:', error);
      }
    }

    /**
     * Genera los informes individuales por trabajador
     */
    function generarInformesIndividuales() {
      try {
        let html = '';
        
        resultadosAnalisis.forEach(resultado => {
          const { nombre, netDeficit, numDeficits, cumplimiento, deficits, tieneDeficit } = resultado;
          
          // Calcular el d√©ficit total ORIGINAL (suma de todos los d√©ficits originales)
          const deficitTotalOriginal = deficits.reduce((sum, d) => sum + (d.deficitOriginal || d.deficit), 0);
          
          const badgeClass = tieneDeficit ? 'warning' : 'success';
          const badgeText = tieneDeficit ? 'Amb D√®ficit' : 'Compleix';
          const cardClass = tieneDeficit ? 'con-deficit' : 'sin-deficit';
          
          html += `
            <div class="informe-trabajador ${cardClass}" data-indice="${resultadosAnalisis.indexOf(resultado)}">
              <div class="informe-header">
                <div class="informe-nombre">${nombre}</div>
                <div style="display: flex; gap: 8px; align-items: center;">
                  <button class="btn-exportar-informe" onclick="exportarInformeIndividual(${resultadosAnalisis.indexOf(resultado)})" title="Exportar informe">
                    <i class="fas fa-file-excel"></i> Exportar
                  </button>
                  <div class="informe-badge ${badgeClass}">${badgeText}</div>
                </div>
              </div>
              
              <div class="informe-detalles">
                <div class="informe-item">
                  <i class="fas fa-clock"></i>
                  <span><strong>D√®ficit Total:</strong> ${formatDuration(deficitTotalOriginal)}</span>
                </div>
                <div class="informe-item">
                  <i class="fas fa-exclamation-triangle"></i>
                  <span><strong>Transicions Deficit√†ries:</strong> ${numDeficits}</span>
                </div>
                <div class="informe-item">
                  <i class="fas fa-percent"></i>
                  <span><strong>Compliment:</strong> ${cumplimiento}%</span>
                </div>
              </div>
          `;
          
          // Detalles de d√©ficits si existen
          if (tieneDeficit && deficits.length > 0) {
            html += `
              <div class="informe-deficits">
                <div class="informe-deficits-title">
                  <i class="fas fa-list"></i> Detall dels D√®ficits
                </div>
                <div class="deficit-list">
            `;
            
            deficits.forEach((deficit, idx) => {
              const { turnoActual, turnoSiguiente, deficitOriginal, deficit: deficitMinutos, compensado, descansoActual } = deficit;
              const textoCompensado = compensado ? ' <span style="color: #ef5350;">(Compensat)</span>' : '';
              
              // Usar siempre el d√©ficit ORIGINAL, no el modificado por compensaci√≥n
              const deficitAMostrar = deficitOriginal || deficitMinutos;
              
              html += `
                <div style="margin-bottom: 6px;">
                  ${idx + 1}. <strong>${turnoActual} ‚Üí ${turnoSiguiente}</strong>: 
                  Descans ${formatDuration(descansoActual)} - D√®ficit de ${formatDuration(deficitAMostrar)}${textoCompensado}
                </div>
              `;
            });
            
            html += `
                </div>
              </div>
            `;
          }
          
          html += `</div>`;
        });
        
        elementosCheck.informesIndividuales.innerHTML = html;
      } catch (error) {
        console.error('Error al generar informes individuales:', error);
      }
    }

    // Inicializar m√≥dulo cuando el DOM est√© listo
    document.addEventListener('DOMContentLoaded', initComprobacion);
    
    // Si el DOM ya est√° cargado, inicializar inmediatamente
    if (document.readyState === 'interactive' || document.readyState === 'complete') {
      initComprobacion();
    }
  </script>
</body>
</html>
